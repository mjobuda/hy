

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>API &mdash; hy 1.0a3+123.gffe6d563 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/overrides.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Hacking on Hy" href="hacking.html" />
    <link rel="prev" title="Cheatsheet" href="cheatsheet.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> hy
          

          
          </a>

          
            
            
              <div class="version">
                1.0a3+123
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="whyhy.html">Why Hy?</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="style-guide.html">Hy Style Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="language/index.html">Documentation Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="cheatsheet.html">Cheatsheet</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#core-macros">Core Macros</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#placeholder-macros">Placeholder macros</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#hy">Hy</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-hy.pyops">Python Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-hy.reserved">Reserved</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="hacking.html">Hacking on Hy</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">hy</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>API</li>
    
    
  <li style="margin-left: 1em">Hy version 1.0a3+123.gffe6d563 <strong style='color: red;'>(unstable)</strong></li>
  
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/api.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    

  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="api">
<h1>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h1>
<div class="section" id="core-macros">
<h2>Core Macros<a class="headerlink" href="#core-macros" title="Permalink to this headline">¶</a></h2>
<p>The following macros are auto imported into all Hy modules as their
base names, such that <code class="docutils literal notranslate"><span class="pre">hy.core.macros.foo</span></code> can be called as just <code class="docutils literal notranslate"><span class="pre">foo</span></code>.</p>
<dl class="hy data">
<dt id="^">
<code class="sig-name descname"><span class="pre">^</span></code><a class="headerlink" href="#^" title="Permalink to this definition">¶</a></dt>
<dd><p>The <code class="docutils literal notranslate"><span class="pre">^</span></code> symbol is used to denote annotations in three different contexts:</p>
<ul class="simple">
<li><p>Standalone variable annotations.</p></li>
<li><p>Variable annotations in a setv call.</p></li>
<li><p>Function argument annotations.</p></li>
</ul>
<p>They implement <a class="reference external" href="https://www.python.org/dev/peps/pep-0526/">PEP 526</a> and
<a class="reference external" href="https://www.python.org/dev/peps/pep-3107/">PEP 3107</a>.</p>
<p>Syntax sugar for <a class="reference internal" href="#annotate" title="annotate"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">annotate</span></code></a>.</p>
<p>Here is some example syntax of all three usages:</p>
<p><strong>Examples</strong></p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="c1">; Annotate the variable x as an int (equivalent to `x: int`).</span>
<span class="p">(</span><span class="o">^</span><span class="nb">int </span><span class="nv">x</span><span class="p">)</span>
<span class="c1">; Can annotate with expressions if needed (equivalent to `y: f(x)`).</span>
<span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">y</span><span class="p">)</span>

<span class="c1">; Annotations with an assignment: each annotation (int, str) covers the term that</span>
<span class="c1">; immediately follows.</span>
<span class="c1">; Equivalent to: x: int = 1; y = 2; z: str = 3</span>
<span class="p">(</span><span class="nf">setv</span> <span class="o">^</span><span class="nb">int </span><span class="nv">x</span> <span class="mi">1</span> <span class="nv">y</span> <span class="mi">2</span> <span class="o">^</span><span class="nb">str </span><span class="nv">z</span> <span class="mi">3</span><span class="p">)</span>

<span class="c1">; Annotate a as an int, c as an int, and b as a str.</span>
<span class="c1">; Equivalent to: def func(a: int, b: str = None, c: int = 1): ...</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">func</span> <span class="p">[</span><span class="o">^</span><span class="nb">int </span><span class="nv">a</span> <span class="o">^</span><span class="nb">str </span><span class="p">[</span><span class="nv">b</span> <span class="nv">None</span><span class="p">]</span> <span class="o">^</span><span class="nb">int </span><span class="p">[</span><span class="nv">c</span> <span class="mi">1</span><span class="p">]]</span> <span class="nv">...</span><span class="p">)</span>

<span class="c1">; Function return annotations come before the function name (if it exists)</span>
<span class="p">(</span><span class="kd">defn </span><span class="o">^</span><span class="nb">int </span><span class="nv">add1</span> <span class="p">[</span><span class="o">^</span><span class="nb">int </span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="mi">1</span><span class="p">))</span>
<span class="p">(</span><span class="k">fn </span><span class="o">^</span><span class="nb">int </span><span class="p">[</span><span class="o">^</span><span class="nb">int </span><span class="nv">y</span><span class="p">]</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">y</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>The rules are:</p>
<ul class="simple">
<li><p>The value to annotate with is the value that immediately follows the caret.</p></li>
<li><p>There must be no space between the caret and the value to annotate, otherwise it will be
interpreted as a bitwise XOR like the Python operator.</p></li>
<li><p>The annotation always comes (and is evaluated) <em>before</em> the value being annotated. This is
unlike Python, where it comes and is evaluated <em>after</em> the value being annotated.</p></li>
</ul>
<p>Note that variable annotations are only supported on Python 3.6+.</p>
<p>For annotating items with generic types, the <code class="xref hy hy-func docutils literal notranslate"><span class="pre">of</span></code> macro will likely be of use.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since the addition of type annotations, identifiers that start with <code class="docutils literal notranslate"><span class="pre">^</span></code>
are considered invalid as hy would try to read them as types.</p>
</div>
</dd></dl>

<dl class="hy function">
<dt id="annotate">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">annotate</span></code>  <em><span class="n"><span class="pre">value</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#annotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Expanded form of <a class="reference internal" href="#^" title="^"><code class="xref hy hy-data docutils literal notranslate"><span class="pre">^</span></code></a>.  Syntactically equal to <code class="docutils literal notranslate"><span class="pre">^</span></code> and usable wherever
you might use <code class="docutils literal notranslate"><span class="pre">^</span></code>:</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">= </span><span class="o">&#39;^</span><span class="nb">int </span><span class="o">&#39;</span><span class="p">(</span><span class="nf">annotate</span> <span class="nv">int</span><span class="p">))</span>
<span class="nv">True</span>

<span class="p">(</span><span class="nf">setv</span> <span class="p">(</span><span class="nf">annotate</span> <span class="nv">int</span><span class="p">)</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">)</span>

<span class="p">(</span><span class="kd">defn </span><span class="p">(</span><span class="nf">annotate</span> <span class="nv">int</span><span class="p">)</span> <span class="nv">add1</span> <span class="p">[(</span><span class="nf">annotate</span> <span class="nv">int</span><span class="p">)</span> <span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<span class="target" id="dot"></span><dl class="hy data">
<dt id=".">
<code class="sig-name descname"><span class="pre">.</span></code><a class="headerlink" href="#." title="Permalink to this definition">¶</a></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 0.10.0.</span></p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">.</span></code> is used to perform attribute access on objects. It uses a small DSL
to allow quick access to attributes and items in a nested data structure.</p>
<p><strong>Examples</strong></p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="k">. </span><span class="nv">foo</span> <span class="p">(</span><span class="nf">bar</span> <span class="s">&quot;qux&quot;</span><span class="p">)</span>  <span class="nv">baz</span> <span class="p">[(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)]</span> <span class="nv">frob</span><span class="p">)</span>
</pre></div>
</div>
<p>Compiles down to:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">foo</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="s2">&quot;qux&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">baz</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">frob</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">.</span></code> compiles its first argument (in the example, <em>foo</em>) as the object on
which to do the attribute dereference. It uses bare symbols as attributes
to access (in the example, <em>baz</em>, <em>frob</em>), Expressions as method calls (as in <em>bar</em>),
and compiles the contents of lists (in the example, <code class="docutils literal notranslate"><span class="pre">[(+</span> <span class="pre">1</span> <span class="pre">2)]</span></code>) for indexation.
Other arguments raise a compilation error.</p>
<p>Access to unknown attributes raises an <a class="reference external" href="https://docs.python.org/3.10/library/exceptions.html#AttributeError" title="(in Python v3.10)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>. Access to
unknown keys raises an <a class="reference external" href="https://docs.python.org/3.10/library/exceptions.html#IndexError" title="(in Python v3.10)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">IndexError</span></code></a> (on lists and tuples) or a
<a class="reference external" href="https://docs.python.org/3.10/library/exceptions.html#KeyError" title="(in Python v3.10)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyError</span></code></a> (on dictionaries).</p>
</dd></dl>

<dl class="hy function">
<dt id="fn">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">fn</span></code>  <em><span class="n"><span class="pre">name</span></span></em> <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">arags</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#fn" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">fn</span></code>, like Python’s <code class="docutils literal notranslate"><span class="pre">lambda</span></code>, can be used to define an anonymous function.
Unlike Python’s <code class="docutils literal notranslate"><span class="pre">lambda</span></code>, the body of the function can comprise several
statements. The parameters are similar to <code class="docutils literal notranslate"><span class="pre">defn</span></code>: the first parameter is
vector of parameters and the rest is the body of the function. <code class="docutils literal notranslate"><span class="pre">fn</span></code> returns a
new function. In the following example, an anonymous function is defined and
passed to another function for filtering output:</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">setv</span> <span class="nv">people</span> <span class="p">[{</span><span class="ss">:name</span> <span class="s">&quot;Alice&quot;</span> <span class="ss">:age</span> <span class="mi">20</span><span class="p">}</span>
<span class="nv">...</span>             <span class="p">{</span><span class="ss">:name</span> <span class="s">&quot;Bob&quot;</span> <span class="ss">:age</span> <span class="mi">25</span><span class="p">}</span>
<span class="nv">...</span>             <span class="p">{</span><span class="ss">:name</span> <span class="s">&quot;Charlie&quot;</span> <span class="ss">:age</span> <span class="mi">50</span><span class="p">}</span>
<span class="nv">...</span>             <span class="p">{</span><span class="ss">:name</span> <span class="s">&quot;Dave&quot;</span> <span class="ss">:age</span> <span class="mi">5</span><span class="p">}])</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">display-people</span> <span class="p">[</span><span class="nv">people</span> <span class="nv">filter</span><span class="p">]</span>
<span class="nv">...</span>  <span class="p">(</span><span class="nb">for </span><span class="p">[</span><span class="nv">person</span> <span class="nv">people</span><span class="p">]</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">filter </span><span class="nv">person</span><span class="p">)</span> <span class="p">(</span><span class="nb">print </span><span class="p">(</span><span class="ss">:name</span> <span class="nv">person</span><span class="p">)))))</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">display-people</span> <span class="nv">people</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">person</span><span class="p">]</span> <span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="ss">:age</span> <span class="nv">person</span><span class="p">)</span> <span class="mi">25</span><span class="p">)))</span>
<span class="nv">Alice</span>
<span class="nv">Dave</span>
</pre></div>
</div>
<p>Just as in normal function definitions, if the first element of the
body is a string, it serves as a docstring. This is useful for giving
class methods docstrings:</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">setv</span> <span class="nv">times-three</span>
<span class="nv">...</span>   <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span>
<span class="nv">...</span>    <span class="s">&quot;Multiplies input by three and returns the result.&quot;</span>
<span class="nv">...</span>    <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="mi">3</span><span class="p">)))</span>
</pre></div>
</div>
<p>This can be confirmed via Python’s built-in <code class="docutils literal notranslate"><span class="pre">help</span></code> function:</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span>=&gt; (help times-three)
Help on function times_three:

times_three(x)
Multiplies input by three and returns result
(END)
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="fn/a">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">fn/a</span></code>  <em><span class="n"><span class="pre">name</span></span></em> <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">args</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#fn/a" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">fn/a</span></code> is a variant of <code class="docutils literal notranslate"><span class="pre">fn</span></code> than defines an anonymous coroutine.
The parameters are similar to <code class="docutils literal notranslate"><span class="pre">defn/a</span></code>: the first parameter is
vector of parameters and the rest is the body of the function. <code class="docutils literal notranslate"><span class="pre">fn/a</span></code> returns a
new coroutine.</p>
</dd></dl>

<dl class="hy function">
<dt id="defn">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">defn</span></code>  <em><span class="n"><span class="pre">name</span></span></em> <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">args</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#defn" title="Permalink to this definition">¶</a></dt>
<dd><p>Define <cite>name</cite> as a function with <cite>args</cite> as the signature, annotations, and body.</p>
<p><code class="docutils literal notranslate"><span class="pre">defn</span></code> is used to define functions. It requires two arguments: a name (given
as a symbol) and a list of parameters (also given as symbols). Any remaining
arguments constitute the body of the function:</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kd">defn </span><span class="nb">name </span><span class="p">[</span><span class="nv">params</span><span class="p">]</span> <span class="nv">bodyform1</span> <span class="nv">bodyform2...</span><span class="p">)</span>
</pre></div>
</div>
<p>If there at least two body forms, and the first of them is a string literal,
this string becomes the <a class="reference external" href="https://docs.python.org/3/glossary.html#term-docstring" title="(in Python v3.9)"><span>docstring</span></a> of the function.</p>
<p>Parameters may be prefixed with the following special symbols. If you use more
than one, they can only appear in the given order (so all positional only arguments
must precede <code class="docutils literal notranslate"><span class="pre">/</span></code>, all positional or keyword arguments must precede a <code class="docutils literal notranslate"><span class="pre">#*</span></code> rest
parameter or <code class="docutils literal notranslate"><span class="pre">*</span></code> kwonly delimiter and <code class="docutils literal notranslate"><span class="pre">#**</span></code> must be the last argument).
This is the same order that Python requires.</p>
<dl>
<dt>/</dt><dd><p>The preceding parameters can only be supplied as positional arguments.</p>
</dd>
<dt>positional or keyword arguments:</dt><dd><p>All parameters until following <code class="docutils literal notranslate"><span class="pre">/</span></code> (if its supplied) but before <code class="docutils literal notranslate"><span class="pre">*/#*/#**</span></code>
can be supplied positionally or by keyword. Optional arguments may be given as
two-argument lists, where the first element is the parameter name and the second
is the default value. When defining parameters, a positional argument cannot follow
a keyword argument.</p>
<p>The following example defines a function with one required positional argument
as well as three optional arguments. The first optional argument defaults to <code class="docutils literal notranslate"><span class="pre">None</span></code>
and the latter two default to <code class="docutils literal notranslate"><span class="pre">\&quot;(\&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">\&quot;)\&quot;</span></code>, respectively:</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">format-pair</span> <span class="p">[</span><span class="nv">left-val</span> <span class="p">[</span><span class="nv">right-val</span> <span class="nv">None</span><span class="p">]</span> <span class="p">[</span><span class="nv">open-text</span> <span class="sc">\&quot;</span><span class="p">(</span><span class="sc">\&quot;</span><span class="p">]</span> <span class="p">[</span><span class="nv">close-text</span> <span class="sc">\&quot;</span><span class="p">)</span><span class="sc">\&quot;</span><span class="p">]]</span>
<span class="nv">...</span>  <span class="p">(</span><span class="nb">+ </span><span class="nv">open-text</span> <span class="p">(</span><span class="nb">str </span><span class="nv">left-val</span><span class="p">)</span> <span class="sc">\&quot;</span>, <span class="sc">\&quot;</span> <span class="p">(</span><span class="nb">str </span><span class="nv">right-val</span><span class="p">)</span> <span class="nv">close-text</span><span class="p">))</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">format-pair</span> <span class="mi">3</span><span class="p">)</span>
<span class="sc">\&quot;</span><span class="p">(</span><span class="mi">3</span>, <span class="nv">None</span><span class="p">)</span><span class="sc">\&quot;</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">format-pair</span> <span class="sc">\&quot;</span><span class="nv">A</span><span class="sc">\&quot;</span> <span class="sc">\&quot;</span><span class="nv">B</span><span class="sc">\&quot;</span><span class="p">)</span>
<span class="sc">\&quot;</span><span class="p">(</span><span class="nf">A</span>, <span class="nv">B</span><span class="p">)</span><span class="sc">\&quot;</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">format-pair</span> <span class="sc">\&quot;</span><span class="nv">A</span><span class="sc">\&quot;</span> <span class="sc">\&quot;</span><span class="nv">B</span><span class="sc">\&quot;</span> <span class="sc">\&quot;</span><span class="nv">&lt;</span><span class="sc">\&quot;</span> <span class="sc">\&quot;</span><span class="nv">&gt;</span><span class="sc">\&quot;</span><span class="p">)</span>
<span class="sc">\&quot;</span><span class="nv">&lt;A</span>, <span class="nv">B&gt;</span><span class="sc">\&quot;</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">format-pair</span> <span class="sc">\&quot;</span><span class="nv">A</span><span class="sc">\&quot;</span> <span class="ss">:open-text</span> <span class="sc">\&quot;</span><span class="nv">&lt;</span><span class="sc">\&quot;</span> <span class="ss">:close-text</span> <span class="sc">\&quot;</span><span class="nv">&gt;</span><span class="sc">\&quot;</span><span class="p">)</span>
<span class="sc">\&quot;</span><span class="nv">&lt;A</span>, <span class="nv">None&gt;</span><span class="sc">\&quot;</span>
</pre></div>
</div>
</dd>
<dt>#*</dt><dd><p>The following parameter will contain a list of 0 or more positional arguments.
No other positional parameters may be specified after this one. Parameters
defined after this but before <code class="docutils literal notranslate"><span class="pre">#**</span></code> are considered keyword only.</p>
<p>The following code example defines a function that can be given 0 to n
numerical parameters. It then sums every odd number and subtracts
every even number:</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">zig-zag-sum</span> <span class="p">[</span><span class="o">#</span><span class="nb">* </span><span class="nv">numbers</span><span class="p">]</span>
     <span class="p">(</span><span class="nf">setv</span> <span class="nv">odd-numbers</span> <span class="p">(</span><span class="nf">lfor</span> <span class="nv">x</span> <span class="nv">numbers</span> <span class="ss">:if</span> <span class="p">(</span><span class="nf">%</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>
           <span class="nv">even-numbers</span> <span class="p">(</span><span class="nf">lfor</span> <span class="nv">x</span> <span class="nv">numbers</span> <span class="ss">:if</span> <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">%</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">x</span><span class="p">))</span>
     <span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nf">sum</span> <span class="nv">odd-numbers</span><span class="p">)</span> <span class="p">(</span><span class="nf">sum</span> <span class="nv">even-numbers</span><span class="p">)))</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">zig-zag-sum</span><span class="p">)</span>
<span class="mi">0</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">zig-zag-sum</span> <span class="mi">3</span> <span class="mi">9</span> <span class="mi">4</span><span class="p">)</span>
<span class="mi">8</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">zig-zag-sum</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">)</span>
<span class="mi">-3</span>
</pre></div>
</div>
</dd>
</dl>
<ul>
<li><p>All following parmaeters can only be supplied as keywords.
Like keyword arguments, the parameter may be marked as optional by
declaring it as a two-element list containing the parameter name
following by the default value. Parameters without a default are
considered required:</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">compare</span> <span class="p">[</span><span class="nv">a</span> <span class="nv">b</span> <span class="nb">* </span><span class="nv">keyfn</span> <span class="p">[</span><span class="nb">reverse </span><span class="nv">False</span><span class="p">]]</span>
<span class="nv">...</span>  <span class="p">(</span><span class="nf">setv</span> <span class="nv">result</span> <span class="p">(</span><span class="nf">keyfn</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>
<span class="nv">...</span>  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="nv">reverse</span><span class="p">)</span>
<span class="nv">...</span>    <span class="nv">result</span>
<span class="nv">...</span>    <span class="p">(</span><span class="nb">- </span><span class="nv">result</span><span class="p">)))</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">compare</span> <span class="sc">\&quot;</span><span class="nv">lisp</span><span class="sc">\&quot;</span> <span class="sc">\&quot;</span><span class="nv">python</span><span class="sc">\&quot;</span>
<span class="nv">...</span>         <span class="ss">:keyfn</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span> <span class="nv">y</span><span class="p">]</span>
<span class="nv">...</span>                  <span class="p">(</span><span class="nb">reduce - </span><span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">s</span><span class="p">]</span> <span class="p">(</span><span class="nf">ord</span> <span class="p">(</span><span class="nb">get </span><span class="nv">s</span> <span class="mi">0</span><span class="p">)))</span> <span class="p">[</span><span class="nv">x</span> <span class="nv">y</span><span class="p">]))))</span>
<span class="mi">-4</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">compare</span> <span class="sc">\&quot;</span><span class="nv">lisp</span><span class="sc">\&quot;</span> <span class="sc">\&quot;</span><span class="nv">python</span><span class="sc">\&quot;</span>
<span class="nv">...</span>         <span class="ss">:keyfn</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span> <span class="nv">y</span><span class="p">]</span>
<span class="nv">...</span>                   <span class="p">(</span><span class="nb">reduce - </span><span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">s</span><span class="p">]</span> <span class="p">(</span><span class="nf">ord</span> <span class="p">(</span><span class="nb">get </span><span class="nv">s</span> <span class="mi">0</span><span class="p">)))</span> <span class="p">[</span><span class="nv">x</span> <span class="nv">y</span><span class="p">])))</span>
<span class="nv">...</span>         <span class="ss">:reverse</span> <span class="nv">True</span><span class="p">)</span>
<span class="mi">4</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="o">=&gt;</span> <span class="p">(</span><span class="n">compare</span> \<span class="s2">&quot;lisp</span><span class="se">\&quot;</span><span class="s2"> </span><span class="se">\&quot;</span><span class="s2">python</span><span class="se">\&quot;</span><span class="s2">)</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> \<span class="s2">&quot;&lt;input&gt;</span><span class="se">\&quot;</span><span class="s2">, line 1, in &lt;module&gt;</span>
<span class="ne">TypeError</span><span class="p">:</span> <span class="n">compare</span><span class="p">()</span> <span class="n">missing</span> <span class="mi">1</span> <span class="n">required</span> <span class="n">keyword</span><span class="o">-</span><span class="n">only</span> <span class="n">argument</span><span class="p">:</span> <span class="s1">&#39;keyfn&#39;</span>
</pre></div>
</div>
</li>
</ul>
<dl>
<dt>#**</dt><dd><p>Like <code class="docutils literal notranslate"><span class="pre">#*</span></code>, but for keyword arguments.
The following parameter will contain 0 or more keyword arguments.</p>
<p>The following code examples defines a function that will print all keyword
arguments and their values:</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">print-parameters</span> <span class="p">[</span><span class="o">#</span><span class="nv">**</span> <span class="nv">kwargs</span><span class="p">]</span>
<span class="nv">...</span>    <span class="p">(</span><span class="nb">for </span><span class="p">[(</span>, <span class="nv">k</span> <span class="nv">v</span><span class="p">)</span> <span class="p">(</span><span class="nf">.items</span> <span class="nv">kwargs</span><span class="p">)]</span> <span class="p">(</span><span class="nb">print </span><span class="nv">k</span> <span class="nv">v</span><span class="p">)))</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">print-parameters</span> <span class="ss">:parameter-1</span> <span class="mi">1</span> <span class="ss">:parameter-2</span> <span class="mi">2</span><span class="p">)</span>
<span class="nv">parameter_1</span> <span class="mi">1</span>
<span class="nv">parameter_2</span> <span class="mi">2</span>

<span class="c1">; to avoid the mangling of &#39;-&#39; to &#39;_&#39;, use unpacking:</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">print-parameters</span> <span class="o">#</span><span class="nv">**</span> <span class="p">{</span><span class="sc">\&quot;</span><span class="nv">parameter-1</span><span class="sc">\&quot;</span> <span class="mi">1</span> <span class="sc">\&quot;</span><span class="nv">parameter-2</span><span class="sc">\&quot;</span> <span class="mi">2</span><span class="p">})</span>
<span class="nv">parameter-1</span> <span class="mi">1</span>
<span class="nv">parameter-2</span> <span class="mi">2</span>
</pre></div>
</div>
</dd>
</dl>
<div class="admonition note" id="reserved-param-names">
<p class="admonition-title">Note</p>
<p>Parameter names cannot be Python reserved words nor can a function
be called with keyword arguments that are Python reserved words. This means
that the following will raise a <cite>SyntaxError</cite> as they would in Python:</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span>(defn afunc [a b if])
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1
    (defn afunc [a b if])
                     ^
hy.errors.HySyntaxError: parameter name cannot be Python reserved word

(dict :a 1 :from 2)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1
    (dict :a 1 :from 2)
               ^
hy.errors.HySyntaxError: keyword argument cannot be Python reserved word
</pre></div>
</div>
<p>This only applies to parameter names and a keyword argument name. The value of
the parameter or keyword argument can still be a keyword of a reserved word:</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nb">test </span><span class="p">[</span><span class="nv">a</span><span class="p">]</span> <span class="nv">a</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">test </span><span class="ss">:a</span> <span class="ss">:from</span><span class="p">)</span>
<span class="ss">:from</span>
</pre></div>
</div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="defn/a">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">defn/a</span></code>  <em><span class="n"><span class="pre">name</span></span></em> <em><span class="n"><span class="pre">lambda-list</span></span></em> <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">body</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#defn/a" title="Permalink to this definition">¶</a></dt>
<dd><p>Define <cite>name</cite> as a function with <cite>lambda-list</cite> signature and body <cite>body</cite>.</p>
<p><code class="docutils literal notranslate"><span class="pre">defn/a</span></code> macro is a variant of <code class="docutils literal notranslate"><span class="pre">defn</span></code> that instead defines
coroutines. It takes three parameters: the <em>name</em> of the function to
define, a vector of <em>parameters</em>, and the <em>body</em> of the function:</p>
<dl>
<dt>Examples:</dt><dd><div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">defn/a</span> <span class="nb">name </span><span class="p">[</span><span class="nv">params</span><span class="p">]</span> <span class="nv">body</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="hy function">
<dt id="defmacro">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">defmacro</span></code>  <em><span class="n"><span class="pre">name</span></span></em> <em><span class="n"><span class="pre">lambda-list</span></span></em> <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">body</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#defmacro" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">defmacro</span></code> is used to define macros. The general format is
<code class="docutils literal notranslate"><span class="pre">(defmacro</span> <span class="pre">name</span> <span class="pre">[parameters]</span> <span class="pre">expr)</span></code>.</p>
<p>The following example defines a macro that can be used to swap order of elements
in code, allowing the user to write code in infix notation, where operator is in
between the operands.</p>
<dl>
<dt>Examples:</dt><dd><div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="kd">defmacro </span><span class="nv">infix</span> <span class="p">[</span><span class="nv">code</span><span class="p">]</span>
<span class="nv">...</span>  <span class="p">(</span><span class="nf">quasiquote</span> <span class="p">(</span>
<span class="nv">...</span>    <span class="p">(</span><span class="nf">unquote</span> <span class="p">(</span><span class="nb">get </span><span class="nv">code</span> <span class="mi">1</span><span class="p">))</span>
<span class="nv">...</span>    <span class="p">(</span><span class="nf">unquote</span> <span class="p">(</span><span class="nb">get </span><span class="nv">code</span> <span class="mi">0</span><span class="p">))</span>
<span class="nv">...</span>    <span class="p">(</span><span class="nf">unquote</span> <span class="p">(</span><span class="nb">get </span><span class="nv">code</span> <span class="mi">2</span><span class="p">)))))</span>
</pre></div>
</div>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">infix</span> <span class="p">(</span><span class="mi">1</span> <span class="nb">+ </span><span class="mi">1</span><span class="p">))</span>
<span class="mi">2</span>
</pre></div>
</div>
</dd>
</dl>
<p>The name of the macro can be given as a string literal instead of a symbol. If the name starts with <cite>#</cite>, the macro can be called on a single argument without parentheses; such a macro is called a tag macro.</p>
<blockquote>
<div><div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="kd">defmacro </span><span class="s">&quot;#x2&quot;</span> <span class="p">[</span><span class="nv">form</span><span class="p">]</span>
<span class="nv">...</span>  <span class="o">`</span><span class="p">(</span><span class="k">do </span><span class="o">~</span><span class="nv">form</span> <span class="o">~</span><span class="nv">form</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">setv</span> <span class="nv">foo</span> <span class="mi">1</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="o">#</span><span class="nv">x2</span> <span class="p">(</span><span class="nf">+=</span> <span class="nv">foo</span> <span class="mi">1</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="nv">foo</span>
<span class="mi">3</span>
</pre></div>
</div>
</div></blockquote>
</dd></dl>

<dl class="hy function">
<dt id="if">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">if</span></code>  <em><span class="pre">test</span> <span class="pre">then</span> <span class="pre">[else</span> <span class="pre">None</span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#if" title="Permalink to this definition">¶</a></dt>
<dd><p>Evalute a test.</p>
<p><code class="docutils literal notranslate"><span class="pre">if</span></code> respects Python <em>truthiness</em>, that is, a <em>test</em> fails if it
evaluates to a “zero” (including values of <code class="docutils literal notranslate"><span class="pre">len</span></code> zero, <code class="docutils literal notranslate"><span class="pre">None</span></code>, and
<code class="docutils literal notranslate"><span class="pre">False</span></code>), and passes otherwise, but values with a <code class="docutils literal notranslate"><span class="pre">__bool__</span></code> method
can override this.</p>
<p><code class="docutils literal notranslate"><span class="pre">if</span></code> takes a <em>test</em> and <em>then</em> expression, plus an
optional <em>else</em> expression at the end, which defaults to <code class="docutils literal notranslate"><span class="pre">None</span></code>.
If no tests pass, <code class="docutils literal notranslate"><span class="pre">if</span></code> selects <em>else</em>.</p>
<dl>
<dt>Examples:</dt><dd><div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">money-left?</span> <span class="nv">account</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">print </span><span class="sc">\&quot;</span><span class="nv">let</span><span class="ss">&#39;s</span> <span class="nv">go</span> <span class="nv">shopping</span><span class="sc">\&quot;</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">print </span><span class="sc">\&quot;</span><span class="nv">let</span><span class="ss">&#39;s</span> <span class="nv">go</span> <span class="nb">and </span><span class="nv">work</span><span class="sc">\&quot;</span><span class="p">))</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="hy function">
<dt id="await">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">await</span></code>  <em><span class="n"><span class="pre">obj</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#await" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">await</span></code> creates an <a class="reference external" href="https://docs.python.org/3/reference/expressions.html#await" title="(in Python v3.9)"><span class="xref std std-ref">await expression</span></a>. It takes exactly one
argument: the object to wait for.</p>
<p><strong>Examples</strong></p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">import </span><span class="nv">asyncio</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">defn/a</span> <span class="nv">main</span> <span class="p">[]</span>
<span class="nv">...</span>    <span class="p">(</span><span class="nb">print </span><span class="s">&quot;hello&quot;</span><span class="p">)</span>
<span class="nv">...</span>    <span class="p">(</span><span class="nb">await </span><span class="p">(</span><span class="nf">asyncio.sleep</span> <span class="mi">1</span><span class="p">))</span>
<span class="nv">...</span>    <span class="p">(</span><span class="nb">print </span><span class="s">&quot;world&quot;</span><span class="p">))</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">asyncio.run</span> <span class="p">(</span><span class="nf">main</span><span class="p">))</span>
<span class="nv">hello</span>
<span class="nv">world</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="break">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">break</span></code><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#break" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">break</span></code> is used to break out from a loop. It terminates the loop immediately.
The following example has an infinite <code class="docutils literal notranslate"><span class="pre">while</span></code> loop that is terminated as soon
as the user enters <em>k</em>.</p>
<p><strong>Examples</strong></p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">while</span> <span class="nv">True</span>
<span class="nv">...</span>   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="s">&quot;k&quot;</span> <span class="p">(</span><span class="nf">input</span> <span class="s">&quot;? &quot;</span><span class="p">))</span>
<span class="nv">...</span>       <span class="p">(</span><span class="nf">break</span><span class="p">)</span>
<span class="nv">...</span>       <span class="p">(</span><span class="nb">print </span><span class="s">&quot;Try again&quot;</span><span class="p">)))</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="chainc">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">chainc</span></code>  <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">args</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#chainc" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">chainc</span></code> creates a <a class="reference external" href="https://docs.python.org/3/reference/expressions.html#comparisons" title="(in Python v3.9)"><span class="xref std std-ref">comparison expression</span></a>. It isn’t
required for unchained comparisons, which have only one comparison operator,
nor for chains of the same operator. For those cases, you can use the
comparison operators directly with Hy’s usual prefix syntax, as in <code class="docutils literal notranslate"><span class="pre">(=</span> <span class="pre">x</span> <span class="pre">1)</span></code>
or <code class="docutils literal notranslate"><span class="pre">(&lt;</span> <span class="pre">1</span> <span class="pre">2</span> <span class="pre">3)</span></code>. The use of <code class="docutils literal notranslate"><span class="pre">chainc</span></code> is to construct chains of
heterogeneous operators, such as <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span> <span class="pre">&lt;</span> <span class="pre">z</span></code>. It uses an infix syntax with
the general form</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span>(chainc ARG OP ARG OP ARG…)
</pre></div>
</div>
<p>Hence, <code class="docutils literal notranslate"><span class="pre">(chainc</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">y</span> <span class="pre">&lt;</span> <span class="pre">z)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">(and</span> <span class="pre">(&lt;=</span> <span class="pre">x</span> <span class="pre">y)</span> <span class="pre">(&lt;</span> <span class="pre">y</span> <span class="pre">z))</span></code>,
including short-circuiting, except that <code class="docutils literal notranslate"><span class="pre">y</span></code> is only evaluated once.</p>
<p>Each <code class="docutils literal notranslate"><span class="pre">ARG</span></code> is an arbitrary form, which does not itself use infix syntax. Use
<a class="reference internal" href="#py" title="py"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">py</span></code></a> if you want fully Python-style operator syntax. You can
also nest <code class="docutils literal notranslate"><span class="pre">chainc</span></code> forms, although this is rarely useful. Each <code class="docutils literal notranslate"><span class="pre">OP</span></code> is a
literal comparison operator; other forms that resolve to a comparison operator
are not allowed.</p>
<p>At least two <code class="docutils literal notranslate"><span class="pre">ARG</span></code>s and one <code class="docutils literal notranslate"><span class="pre">OP</span></code> are required, and every <code class="docutils literal notranslate"><span class="pre">OP</span></code> must be
followed by an <code class="docutils literal notranslate"><span class="pre">ARG</span></code>.</p>
<p>As elsewhere in Hy, the equality operator is spelled <code class="docutils literal notranslate"><span class="pre">=</span></code>, not <code class="docutils literal notranslate"><span class="pre">==</span></code> as in
Python.</p>
</dd></dl>

<dl class="hy function">
<dt id="continue">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">continue</span></code><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#continue" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">continue</span></code> returns execution to the start of a loop. In the following example,
<code class="docutils literal notranslate"><span class="pre">(side-effect1)</span></code> is called for each iteration. <code class="docutils literal notranslate"><span class="pre">(side-effect2)</span></code>, however,
is only called on every other value in the list.</p>
<p><strong>Examples</strong></p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="c1">;; assuming that (side-effect1) and (side-effect2) are functions and</span>
<span class="nv">=&gt;</span> <span class="c1">;; collection is a list of numerical values</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">for </span><span class="p">[</span><span class="nv">x</span> <span class="nv">collection</span><span class="p">]</span>
<span class="nv">...</span>   <span class="p">(</span><span class="nf">side-effect1</span> <span class="nv">x</span><span class="p">)</span>
<span class="nv">...</span>   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">%</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">)</span>
<span class="nv">...</span>     <span class="p">(</span><span class="nf">continue</span><span class="p">))</span>
<span class="nv">...</span>   <span class="p">(</span><span class="nf">side-effect2</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="do">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">do</span></code>  <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">body</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#do" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">do</span></code> (called <code class="docutils literal notranslate"><span class="pre">progn</span></code> in some Lisps) takes any number of forms,
evaluates them, and returns the value of the last one, or <code class="docutils literal notranslate"><span class="pre">None</span></code> if no
forms were provided.</p>
<p><strong>Examples</strong></p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nf">setv</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">1</span><span class="p">))</span> <span class="nv">x</span><span class="p">))</span>
<span class="mi">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="for">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">for</span></code>  <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">args</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#for" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">for</span></code> is used to evaluate some forms for each element in an iterable
object, such as a list. The return values of the forms are discarded and
the <code class="docutils literal notranslate"><span class="pre">for</span></code> form returns <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">for </span><span class="p">[</span><span class="nv">x</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]]</span>
<span class="nv">...</span>  <span class="p">(</span><span class="nb">print </span><span class="s">&quot;iterating&quot;</span><span class="p">)</span>
<span class="nv">...</span>  <span class="p">(</span><span class="nb">print </span><span class="nv">x</span><span class="p">))</span>
<span class="nv">iterating</span>
<span class="mi">1</span>
<span class="nv">iterating</span>
<span class="mi">2</span>
<span class="nv">iterating</span>
<span class="mi">3</span>
</pre></div>
</div>
<p>In its square-bracketed first argument, <code class="docutils literal notranslate"><span class="pre">for</span></code> allows the same types of
clauses as <a href="#id1"><span class="problematic" id="id2">:hy:function:`lfor`</span></a>.</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">for </span><span class="p">[</span><span class="nv">x</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span>  <span class="ss">:if</span> <span class="p">(</span><span class="nf">!=</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">)</span>  <span class="nv">y</span> <span class="p">[</span><span class="mi">7</span> <span class="mi">8</span><span class="p">]]</span>
<span class="nv">...</span>  <span class="p">(</span><span class="nb">print </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
<span class="mi">1</span> <span class="mi">7</span>
<span class="mi">1</span> <span class="mi">8</span>
<span class="mi">3</span> <span class="mi">7</span>
<span class="mi">3</span> <span class="mi">8</span>
</pre></div>
</div>
<p>Furthermore, the last argument of <code class="docutils literal notranslate"><span class="pre">for</span></code> can be an <code class="docutils literal notranslate"><span class="pre">(else</span> <span class="pre">…)</span></code> form.
This form is executed after the last iteration of the <code class="docutils literal notranslate"><span class="pre">for</span></code>'s
outermost iteration clause, but only if that outermost loop terminates
normally. If it’s jumped out of with e.g. <code class="docutils literal notranslate"><span class="pre">break</span></code>, the <code class="docutils literal notranslate"><span class="pre">else</span></code> is
ignored.</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">for </span><span class="p">[</span><span class="nv">element</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]]</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">element</span> <span class="mi">3</span><span class="p">)</span>
<span class="nv">...</span>                             <span class="p">(</span><span class="nb">print </span><span class="nv">element</span><span class="p">)</span>
<span class="nv">...</span>                             <span class="p">(</span><span class="nf">break</span><span class="p">))</span>
<span class="nv">...</span>    <span class="p">(</span><span class="nf">else</span> <span class="p">(</span><span class="nb">print </span><span class="s">&quot;loop finished&quot;</span><span class="p">)))</span>
<span class="mi">1</span>
<span class="mi">2</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">for </span><span class="p">[</span><span class="nv">element</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]]</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">element</span> <span class="mi">4</span><span class="p">)</span>
<span class="nv">...</span>                             <span class="p">(</span><span class="nb">print </span><span class="nv">element</span><span class="p">)</span>
<span class="nv">...</span>                             <span class="p">(</span><span class="nf">break</span><span class="p">))</span>
<span class="nv">...</span>    <span class="p">(</span><span class="nf">else</span> <span class="p">(</span><span class="nb">print </span><span class="s">&quot;loop finished&quot;</span><span class="p">)))</span>
<span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
<span class="k">loop </span><span class="nv">finished</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="assert">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">assert</span></code>  <em><span class="n"><span class="pre">condition</span></span></em> <em><span class="pre">[</span><span class="n"><span class="pre">label</span></span><span class="o"> </span><span class="default_value"><span class="pre">None</span></span><span class="pre">]</span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#assert" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">assert</span></code> is used to verify conditions while the program is
running. If the condition is not met, an <a class="reference external" href="https://docs.python.org/3.10/library/exceptions.html#AssertionError" title="(in Python v3.10)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a> is
raised. <code class="docutils literal notranslate"><span class="pre">assert</span></code> may take one or two parameters.  The first
parameter is the condition to check, and it should evaluate to either
<code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>. The second parameter, optional, is a label for
the assert, and is the string that will be raised with the
<a class="reference external" href="https://docs.python.org/3.10/library/exceptions.html#AssertionError" title="(in Python v3.10)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AssertionError</span></code></a>. For example:</p>
<p><strong>Examples</strong></p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="nv">variable</span> <span class="nv">expected-value</span><span class="p">))</span>

<span class="p">(</span><span class="nb">assert </span><span class="nv">False</span><span class="p">)</span>
<span class="c1">; AssertionError</span>

<span class="p">(</span><span class="nb">assert </span><span class="p">(</span><span class="nb">= </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="s">&quot;one should equal two&quot;</span><span class="p">)</span>
<span class="c1">; AssertionError: one should equal two</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="global">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">global</span></code>  <em><span class="n"><span class="pre">sym</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#global" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">global</span></code> can be used to mark a symbol as global. This allows the programmer to
assign a value to a global symbol. Reading a global symbol does not require the
<code class="docutils literal notranslate"><span class="pre">global</span></code> keyword – only assigning it does.</p>
<p>The following example shows how the global symbol <code class="docutils literal notranslate"><span class="pre">a</span></code> is assigned a value in a
function and is later on printed in another function. Without the <code class="docutils literal notranslate"><span class="pre">global</span></code>
keyword, the second function would have raised a <code class="docutils literal notranslate"><span class="pre">NameError</span></code>.</p>
<p><strong>Examples</strong></p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kd">defn </span><span class="nv">set-a</span> <span class="p">[</span><span class="nv">value</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">global</span> <span class="nv">a</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">setv</span> <span class="nv">a</span> <span class="nv">value</span><span class="p">))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">print-a</span> <span class="p">[]</span>
  <span class="p">(</span><span class="nb">print </span><span class="nv">a</span><span class="p">))</span>

<span class="p">(</span><span class="nf">set-a</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">(</span><span class="nf">print-a</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="get">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">get</span></code>  <em><span class="n"><span class="pre">coll</span></span></em> <em><span class="n"><span class="pre">key1</span></span></em> <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">keys</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#get" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">get</span></code> is used to access single elements in collections. <code class="docutils literal notranslate"><span class="pre">get</span></code> takes at
least two parameters: the <em>data structure</em> and the <em>index</em> or <em>key</em> of the
item. It will then return the corresponding value from the collection. If
multiple <em>index</em> or <em>key</em> values are provided, they are used to access
successive elements in a nested structure. Example usage:</p>
<p><a href="#id3"><span class="problematic" id="id4">:string:`Examples`</span></a></p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">do</span>
<span class="nv">...</span>  <span class="p">(</span><span class="nf">setv</span> <span class="nv">animals</span> <span class="p">{</span><span class="s">&quot;dog&quot;</span> <span class="s">&quot;bark&quot;</span> <span class="s">&quot;cat&quot;</span> <span class="s">&quot;meow&quot;</span><span class="p">}</span>
<span class="nv">...</span>        <span class="nv">numbers</span> <span class="p">(</span>, <span class="s">&quot;zero&quot;</span> <span class="s">&quot;one&quot;</span> <span class="s">&quot;two&quot;</span> <span class="s">&quot;three&quot;</span><span class="p">)</span>
<span class="nv">...</span>        <span class="nv">nested</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="p">[</span><span class="s">&quot;a&quot;</span> <span class="s">&quot;b&quot;</span> <span class="s">&quot;c&quot;</span><span class="p">]</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">])</span>
<span class="nv">...</span>  <span class="p">(</span><span class="nb">print </span><span class="p">(</span><span class="nb">get </span><span class="nv">animals</span> <span class="s">&quot;dog&quot;</span><span class="p">))</span>
<span class="nv">...</span>  <span class="p">(</span><span class="nb">print </span><span class="p">(</span><span class="nb">get </span><span class="nv">numbers</span> <span class="mi">2</span><span class="p">))</span>
<span class="nv">...</span>  <span class="p">(</span><span class="nb">print </span><span class="p">(</span><span class="nb">get </span><span class="nv">nested</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">)))</span>

<span class="nv">bark</span>
<span class="nv">two</span>
<span class="nv">b</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">get</span></code> raises a KeyError if a dictionary is queried for a
non-existing key.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">get</span></code> raises an IndexError if a list or a tuple is queried for an
index that is out of bounds.</p>
</div>
</dd></dl>

<dl class="hy function">
<dt id="import">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">import</span></code>  <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">forms</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#import" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">import</span></code> is used to import modules, like in Python. There are several ways
that <code class="docutils literal notranslate"><span class="pre">import</span></code> can be used.</p>
<p><strong>Examples</strong></p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="c1">;; Imports each of these modules</span>
<span class="c1">;;</span>
<span class="c1">;; Python:</span>
<span class="c1">;; import sys</span>
<span class="c1">;; import os.path</span>
<span class="p">(</span><span class="nb">import </span><span class="nv">sys</span> <span class="nv">os.path</span><span class="p">)</span>

<span class="c1">;; Import from a module</span>
<span class="c1">;;</span>
<span class="c1">;; Python: from os.path import exists, isdir, isfile</span>
<span class="p">(</span><span class="nb">import </span><span class="nv">os.path</span> <span class="p">[</span><span class="nv">exists</span> <span class="nv">isdir</span> <span class="nv">isfile</span><span class="p">])</span>

<span class="c1">;; Import with an alias</span>
<span class="c1">;;</span>
<span class="c1">;; Python: import sys as systest</span>
<span class="p">(</span><span class="nb">import </span><span class="nv">sys</span> <span class="ss">:as</span> <span class="nv">systest</span><span class="p">)</span>

<span class="c1">;; You can list as many imports as you like of different types.</span>
<span class="c1">;;</span>
<span class="c1">;; Python:</span>
<span class="c1">;; from tests.resources import kwtest, function_with_a_dash</span>
<span class="c1">;; from os.path import exists, isdir as is_dir, isfile as is_file</span>
<span class="c1">;; import sys as systest</span>
<span class="p">(</span><span class="nb">import </span><span class="nv">tests.resources</span> <span class="p">[</span><span class="nv">kwtest</span> <span class="nv">function-with-a-dash</span><span class="p">]</span>
        <span class="nv">os.path</span> <span class="p">[</span><span class="nv">exists</span>
                 <span class="nv">isdir</span> <span class="ss">:as</span> <span class="nv">dir?</span>
                 <span class="nv">isfile</span> <span class="ss">:as</span> <span class="nv">file?</span><span class="p">]</span>
        <span class="nv">sys</span> <span class="ss">:as</span> <span class="nv">systest</span><span class="p">)</span>

<span class="c1">;; Import all module functions into current namespace</span>
<span class="c1">;;</span>
<span class="c1">;; Python: from sys import *</span>
<span class="p">(</span><span class="nb">import </span><span class="nv">sys</span> <span class="nv">*</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="eval-and-compile">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">eval-and-compile</span></code>  <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">body</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#eval-and-compile" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">eval-and-compile</span></code> is a special form that takes any number of forms. The input forms are evaluated as soon as the <code class="docutils literal notranslate"><span class="pre">eval-and-compile</span></code> form is compiled, instead of being deferred until run-time. The input forms are also left in the program so they can be executed at run-time as usual. So, if you compile and immediately execute a program (as calling <code class="docutils literal notranslate"><span class="pre">hy</span> <span class="pre">foo.hy</span></code> does when <code class="docutils literal notranslate"><span class="pre">foo.hy</span></code> doesn’t have an up-to-date byte-compiled version), <code class="docutils literal notranslate"><span class="pre">eval-and-compile</span></code> forms will be evaluated twice.</p>
<p>One possible use of <code class="docutils literal notranslate"><span class="pre">eval-and-compile</span></code> is to make a function available both at compile-time (so a macro can call it while expanding) and run-time (so it can be called like any other function):</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">eval-and-compile</span>
  <span class="p">(</span><span class="kd">defn </span><span class="nv">add</span> <span class="p">[</span><span class="nv">x</span> <span class="nv">y</span><span class="p">]</span>
    <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defmacro </span><span class="nv">m</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">add</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">))</span>

<span class="p">(</span><span class="nb">print </span><span class="p">(</span><span class="nf">m</span> <span class="mi">3</span><span class="p">))</span>     <span class="c1">; prints 5</span>
<span class="p">(</span><span class="nb">print </span><span class="p">(</span><span class="nf">add</span> <span class="mi">3</span> <span class="mi">6</span><span class="p">))</span> <span class="c1">; prints 9</span>
</pre></div>
</div>
<p>Had the <code class="docutils literal notranslate"><span class="pre">defn</span></code> not been wrapped in <code class="docutils literal notranslate"><span class="pre">eval-and-compile</span></code>, <code class="docutils literal notranslate"><span class="pre">m</span></code> wouldn’t be able to call <code class="docutils literal notranslate"><span class="pre">add</span></code>, because when the compiler was expanding <code class="docutils literal notranslate"><span class="pre">(m</span> <span class="pre">3)</span></code>, <code class="docutils literal notranslate"><span class="pre">add</span></code> wouldn’t exist yet.</p>
</dd></dl>

<dl class="hy function">
<dt id="eval-when-compile">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">eval-when-compile</span></code>  <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">body</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#eval-when-compile" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">eval-when-compile</span></code> is like <code class="docutils literal notranslate"><span class="pre">eval-and-compile</span></code>, but the code isn’t executed at run-time. Hence, <code class="docutils literal notranslate"><span class="pre">eval-when-compile</span></code> doesn’t directly contribute any code to the final program, although it can still change Hy’s state while compiling (e.g., by defining a function).</p>
<p><strong>Examples</strong></p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">eval-when-compile</span>
  <span class="p">(</span><span class="kd">defn </span><span class="nv">add</span> <span class="p">[</span><span class="nv">x</span> <span class="nv">y</span><span class="p">]</span>
    <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>

<span class="p">(</span><span class="kd">defmacro </span><span class="nv">m</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">add</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">))</span>

<span class="p">(</span><span class="nb">print </span><span class="p">(</span><span class="nf">m</span> <span class="mi">3</span><span class="p">))</span>     <span class="c1">; prints 5</span>
<span class="p">(</span><span class="nb">print </span><span class="p">(</span><span class="nf">add</span> <span class="mi">3</span> <span class="mi">6</span><span class="p">))</span> <span class="c1">; raises NameError: name &#39;add&#39; is not defined</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="lfor">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">lfor</span></code>  <em><span class="n"><span class="pre">binding</span></span></em> <em><span class="n"><span class="pre">iterable</span></span></em> <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">body</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#lfor" title="Permalink to this definition">¶</a></dt>
<dd><p>The comprehension forms <code class="docutils literal notranslate"><span class="pre">lfor</span></code>, <a href="#id5"><span class="problematic" id="id6">:hy:function:`sfor`</span></a>, <a class="reference internal" href="#dfor" title="dfor"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">dfor</span></code></a>, <a class="reference internal" href="#gfor" title="gfor"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">gfor</span></code></a>, and <a class="reference internal" href="#for" title="for"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">for</span></code></a>
are used to produce various kinds of loops, including Python-style
<a class="reference external" href="https://docs.python.org/3/reference/expressions.html#comprehensions" title="(in Python v3.9)"><span class="xref std std-ref">comprehensions</span></a>. <code class="docutils literal notranslate"><span class="pre">lfor</span></code> in particular
creates a list comprehension. A simple use of <code class="docutils literal notranslate"><span class="pre">lfor</span></code> is:</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">lfor</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">range </span><span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="nv">x</span><span class="p">))</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">2</span> <span class="mi">4</span> <span class="mi">6</span> <span class="mi">8</span><span class="p">]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">x</span></code> is the name of a new variable, which is bound to each element of
<code class="docutils literal notranslate"><span class="pre">(range</span> <span class="pre">5)</span></code>. Each such element in turn is used to evaluate the value
form <code class="docutils literal notranslate"><span class="pre">(*</span> <span class="pre">2</span> <span class="pre">x)</span></code>, and the results are accumulated into a list.</p>
<p>Here’s a more complex example:</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">lfor</span>
<span class="nv">...</span>  <span class="nv">x</span> <span class="p">(</span><span class="nb">range </span><span class="mi">3</span><span class="p">)</span>
<span class="nv">...</span>  <span class="nv">y</span> <span class="p">(</span><span class="nb">range </span><span class="mi">3</span><span class="p">)</span>
<span class="nv">...</span>  <span class="ss">:if</span> <span class="p">(</span><span class="nf">!=</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
<span class="nv">...</span>  <span class="ss">:setv</span> <span class="nv">total</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
<span class="nv">...</span>  <span class="p">[</span><span class="nv">x</span> <span class="nv">y</span> <span class="nv">total</span><span class="p">])</span>
<span class="p">[[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">]</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">]</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span> <span class="mi">0</span> <span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span> <span class="mi">1</span> <span class="mi">3</span><span class="p">]]</span>
</pre></div>
</div>
<p>When there are several iteration clauses (here, the pairs of forms <code class="docutils literal notranslate"><span class="pre">x</span>
<span class="pre">(range</span> <span class="pre">3)</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">(range</span> <span class="pre">3)</span></code>), the result works like a nested loop or
Cartesian product: all combinations are considered in lexicographic
order.</p>
<p>The general form of <code class="docutils literal notranslate"><span class="pre">lfor</span></code> is:</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">lfor</span> <span class="nv">CLAUSES</span> <span class="nv">VALUE</span><span class="p">)</span>
</pre></div>
</div>
<p>where the <code class="docutils literal notranslate"><span class="pre">VALUE</span></code> is an arbitrary form that is evaluated to produce
each element of the result list, and <code class="docutils literal notranslate"><span class="pre">CLAUSES</span></code> is any number of
clauses. There are several types of clauses:</p>
<ul class="simple">
<li><p>Iteration clauses, which look like <code class="docutils literal notranslate"><span class="pre">LVALUE</span> <span class="pre">ITERABLE</span></code>. The <code class="docutils literal notranslate"><span class="pre">LVALUE</span></code>
is usually just a symbol, but could be something more complicated,
like <code class="docutils literal notranslate"><span class="pre">[x</span> <span class="pre">y]</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">:async</span> <span class="pre">LVALUE</span> <span class="pre">ITERABLE</span></code>, which is an
<a class="reference external" href="https://docs.python.org/3/reference/compound_stmts.html#async-for" title="(in Python v3.9)"><span class="xref std std-ref">asynchronous</span></a> form of iteration clause.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">:do</span> <span class="pre">FORM</span></code>, which simply evaluates the <code class="docutils literal notranslate"><span class="pre">FORM</span></code>. If you use
<code class="docutils literal notranslate"><span class="pre">(continue)</span></code> or <code class="docutils literal notranslate"><span class="pre">(break)</span></code> here, they will apply to the innermost
iteration clause before the <code class="docutils literal notranslate"><span class="pre">:do</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">:setv</span> <span class="pre">LVALUE</span> <span class="pre">RVALUE</span></code>, which is equivalent to <code class="docutils literal notranslate"><span class="pre">:do</span> <span class="pre">(setv</span> <span class="pre">LVALUE</span>
<span class="pre">RVALUE)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">:if</span> <span class="pre">CONDITION</span></code>, which is equivalent to <code class="docutils literal notranslate"><span class="pre">:do</span> <span class="pre">(if</span> <span class="pre">(not</span> <span class="pre">CONDITION)</span>
<span class="pre">(continue))</span></code>.</p></li>
</ul>
<p>For <code class="docutils literal notranslate"><span class="pre">lfor</span></code>, <code class="docutils literal notranslate"><span class="pre">sfor</span></code>, <code class="docutils literal notranslate"><span class="pre">gfor</span></code>, and <code class="docutils literal notranslate"><span class="pre">dfor</span></code>, variables are scoped as
if the comprehension form were its own function, so variables defined by
an iteration clause or <code class="docutils literal notranslate"><span class="pre">:setv</span></code> are not visible outside the form. In
fact, these forms are implemented as generator functions whenever they
contain Python statements, with the attendant consequences for calling
<code class="docutils literal notranslate"><span class="pre">return</span></code>. By contrast, <code class="docutils literal notranslate"><span class="pre">for</span></code> shares the caller’s scope.</p>
</dd></dl>

<dl class="hy function">
<dt id="dfor">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">dfor</span></code>  <em><span class="n"><span class="pre">binding</span></span></em> <em><span class="n"><span class="pre">iterable</span></span></em> <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">body</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#dfor" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">dfor</span></code> creates a <a class="reference external" href="https://docs.python.org/3/reference/expressions.html#dict" title="(in Python v3.9)"><span class="xref std std-ref">dictionary comprehension</span></a>. Its syntax
is the same as that of <cite>:hy:func:`lfor</cite> except that the final value form must be
a literal list of two elements, the first of which becomes each key and
the second of which becomes each value.</p>
<p><strong>Examples</strong></p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">dfor</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">range </span><span class="mi">5</span><span class="p">)</span> <span class="p">[</span><span class="nv">x</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="mi">10</span><span class="p">)])</span>
<span class="p">{</span><span class="mi">0</span> <span class="mi">0</span>  <span class="mi">1</span> <span class="mi">10</span>  <span class="mi">2</span> <span class="mi">20</span>  <span class="mi">3</span> <span class="mi">30</span>  <span class="mi">4</span> <span class="mi">40</span><span class="p">}</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="gfor">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">gfor</span></code>  <em><span class="n"><span class="pre">binding</span></span></em> <em><span class="n"><span class="pre">iterable</span></span></em> <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">body</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#gfor" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">gfor</span></code> creates a <a class="reference external" href="https://docs.python.org/3/reference/expressions.html#genexpr" title="(in Python v3.9)"><span class="xref std std-ref">generator expression</span></a>. Its syntax
is the same as that of <a class="reference internal" href="#lfor" title="lfor"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">lfor</span></code></a>. The difference is that <code class="docutils literal notranslate"><span class="pre">gfor</span></code> returns
an iterator, which evaluates and yields values one at a time.</p>
<p><strong>Examples</strong></p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">import </span><span class="nv">itertools</span> <span class="p">[</span><span class="nb">count </span><span class="nv">take-while</span><span class="p">])</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">setv</span> <span class="nv">accum</span> <span class="p">[])</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nf">take-while</span>
<span class="nv">...</span>  <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">&lt; </span><span class="nv">x</span> <span class="mi">5</span><span class="p">))</span>
<span class="nv">...</span>  <span class="p">(</span><span class="nf">gfor</span> <span class="nv">x</span> <span class="p">(</span><span class="nf">count</span><span class="p">)</span> <span class="ss">:do</span> <span class="p">(</span><span class="nf">.append</span> <span class="nv">accum</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)))</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]</span>
<span class="nv">=&gt;</span> <span class="nv">accum</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="sfor">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">sfor</span></code>  <em><span class="n"><span class="pre">binding</span></span></em> <em><span class="n"><span class="pre">iterable</span></span></em> <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">body</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#sfor" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">sfor</span></code> creates a set comprehension. <code class="docutils literal notranslate"><span class="pre">(sfor</span> <span class="pre">CLAUSES</span> <span class="pre">VALUE)</span></code> is
equivalent to <code class="docutils literal notranslate"><span class="pre">(set</span> <span class="pre">(lfor</span> <span class="pre">CLAUSES</span> <span class="pre">VALUE))</span></code>. See <a class="reference internal" href="#lfor" title="lfor"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">lfor</span></code></a>.</p>
</dd></dl>

<dl class="hy function">
<dt id="setv">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">setv</span></code>  <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">args</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#setv" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">setv</span></code> is used to bind a value, object, or function to a symbol.</p>
<p><strong>Examples</strong></p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">setv</span> <span class="nv">names</span> <span class="p">[</span><span class="s">&quot;Alice&quot;</span> <span class="s">&quot;Bob&quot;</span> <span class="s">&quot;Charlie&quot;</span><span class="p">])</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">print </span><span class="nv">names</span><span class="p">)</span>
<span class="p">[</span><span class="ss">&#39;Alice</span><span class="o">&#39;</span>, <span class="ss">&#39;Bob</span><span class="o">&#39;</span>, <span class="ss">&#39;Charlie</span><span class="o">&#39;</span><span class="p">]</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">setv</span> <span class="nv">counter</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">collection</span> <span class="nv">item</span><span class="p">]</span> <span class="p">(</span><span class="nf">.count</span> <span class="nv">collection</span> <span class="nv">item</span><span class="p">)))</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">counter</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">2</span>
</pre></div>
</div>
<p>You can provide more than one target–value pair, and the assignments will be made in order:</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">setv</span>  <span class="nv">x</span> <span class="mi">1</span>  <span class="nv">y</span> <span class="nv">x</span>  <span class="nv">x</span> <span class="mi">2</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">print </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
<span class="mi">2</span> <span class="mi">1</span>
</pre></div>
</div>
<p>You can perform parallel assignments or unpack the source value with square brackets and <a class="reference internal" href="#unpack-iterable/unpack-mapping" title="unpack-iterable/unpack-mapping"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">unpack-iterable</span></code></a>:</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">setv</span> <span class="nv">duo</span> <span class="p">[</span><span class="s">&quot;tim&quot;</span> <span class="s">&quot;eric&quot;</span><span class="p">])</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">setv</span> <span class="p">[</span><span class="nv">guy1</span> <span class="nv">guy2</span><span class="p">]</span> <span class="nv">duo</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">print </span><span class="nv">guy1</span> <span class="nv">guy2</span><span class="p">)</span>
<span class="nv">tim</span> <span class="nv">eric</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">setv</span> <span class="p">[</span><span class="nv">letter1</span> <span class="nv">letter2</span> <span class="o">#</span><span class="nb">* </span><span class="nv">others</span><span class="p">]</span> <span class="s">&quot;abcdefg&quot;</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">print </span><span class="nv">letter1</span> <span class="nv">letter2</span> <span class="nv">others</span><span class="p">)</span>
<span class="nv">a</span> <span class="nv">b</span> <span class="p">[</span><span class="ss">&#39;c</span><span class="o">&#39;</span>, <span class="ss">&#39;d</span><span class="o">&#39;</span>, <span class="ss">&#39;e</span><span class="o">&#39;</span>, <span class="ss">&#39;f</span><span class="o">&#39;</span>, <span class="ss">&#39;g</span><span class="o">&#39;</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="setx">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">setx</span></code>  <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">args</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#setx" title="Permalink to this definition">¶</a></dt>
<dd><p>Whereas <code class="docutils literal notranslate"><span class="pre">setv</span></code> creates an assignment statement, <code class="docutils literal notranslate"><span class="pre">setx</span></code> creates an assignment expression (see <span class="target" id="index-0"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0572"><strong>PEP 572</strong></a>). It requires Python 3.8 or later. Only one target–value pair is allowed, and the target must be a bare symbol, but the <code class="docutils literal notranslate"><span class="pre">setx</span></code> form returns the assigned value instead of <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p><strong>Examples</strong></p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">&gt; </span><span class="p">(</span><span class="nf">setx</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span> <span class="mi">0</span><span class="p">)</span>
<span class="nv">...</span>  <span class="p">(</span><span class="nb">print </span><span class="nv">x</span> <span class="s">&quot;is greater than 0&quot;</span><span class="p">))</span>
<span class="mi">3</span> <span class="nv">is</span> <span class="nv">greater</span> <span class="nv">than</span> <span class="mi">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="match">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">match</span></code>  <em><span class="n"><span class="pre">subject</span></span></em> <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">cases</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#match" title="Permalink to this definition">¶</a></dt>
<dd><p>The <code class="docutils literal notranslate"><span class="pre">match</span></code> form creates a <a class="reference external" href="https://docs.python.org/3.10/reference/compound_stmts.html#match" title="(in Python v3.10)"><span class="xref std std-ref">match statement</span></a>. It
requires Python 3.10 or later. The first argument should be the subject,
and any remaining arguments should be pairs of patterns and results. The
<code class="docutils literal notranslate"><span class="pre">match</span></code> form returns the value of the corresponding result, or
<code class="docutils literal notranslate"><span class="pre">None</span></code> if no case matched. For example:</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">match</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">1</span><span class="p">)</span>
<span class="nv">...</span>  <span class="mi">1</span> <span class="s">&quot;one&quot;</span>
<span class="nv">...</span>  <span class="mi">2</span> <span class="s">&quot;two&quot;</span>
<span class="nv">...</span>  <span class="mi">3</span> <span class="s">&quot;three&quot;</span><span class="p">)</span>
<span class="s">&quot;two&quot;</span>
</pre></div>
</div>
<p>You can use <a class="reference internal" href="#do" title="do"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">do</span></code></a> to build a complex result form. Patterns, as
in Python match statements, are interpreted specially and can’t be
arbitrary forms. Use <code class="docutils literal notranslate"><span class="pre">(|</span> <span class="pre">…)</span></code> for OR patterns, <code class="docutils literal notranslate"><span class="pre">PATTERN</span> <span class="pre">:as</span> <span class="pre">NAME</span></code> for
AS patterns, and syntax like the usual Hy syntax for literal, capture,
value, sequence, mapping, and class patterns. Guards are specified
with <code class="docutils literal notranslate"><span class="pre">:if</span> <span class="pre">FORM</span></code>. Here’s a more complex example:</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">match</span> <span class="p">(</span>, <span class="mi">100</span> <span class="mi">200</span><span class="p">)</span>
<span class="nv">...</span>  <span class="p">[</span><span class="mi">100</span> <span class="mi">300</span><span class="p">]</span>               <span class="s">&quot;Case 1&quot;</span>
<span class="nv">...</span>  <span class="p">[</span><span class="mi">100</span> <span class="mi">200</span><span class="p">]</span> <span class="ss">:if</span> <span class="nv">flag</span>      <span class="s">&quot;Case 2&quot;</span>
<span class="nv">...</span>  <span class="p">[</span><span class="mi">900</span>   <span class="nv">y</span><span class="p">]</span>               <span class="nv">f</span><span class="s">&quot;Case 3, y: {y}&quot;</span>
<span class="nv">...</span>  <span class="p">[</span><span class="mi">100</span> <span class="p">(</span><span class="nf">|</span> <span class="mi">100</span> <span class="mi">200</span><span class="p">)</span> <span class="ss">:as</span> <span class="nv">y</span><span class="p">]</span> <span class="nv">f</span><span class="s">&quot;Case 4, y: {y}&quot;</span>
<span class="nv">...</span>  <span class="nv">_</span>                       <span class="s">&quot;Case 5, I match anything!&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>This will match case 2 if <code class="docutils literal notranslate"><span class="pre">flag</span></code> is true and case 4 otherwise.</p>
<p><code class="docutils literal notranslate"><span class="pre">match</span></code> can also match against class instances by keyword (or
positionally if its <code class="docutils literal notranslate"><span class="pre">__match_args__</span></code> attribute is defined, see
<a class="reference external" href="https://www.python.org/dev/peps/pep-0636/#appendix-a-quick-intro">pep 636</a>):</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">with-decorator</span>
<span class="nv">...</span>  <span class="nv">dataclass</span>
<span class="nv">...</span>  <span class="p">(</span><span class="nf">defclass</span> <span class="nv">Point</span> <span class="p">[]</span>
<span class="nv">...</span>    <span class="p">(</span><span class="o">^</span><span class="nb">int </span><span class="nv">x</span><span class="p">)</span>
<span class="nv">...</span>    <span class="p">(</span><span class="o">^</span><span class="nb">int </span><span class="nv">y</span><span class="p">)))</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">match</span> <span class="p">(</span><span class="nf">Point</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
<span class="nv">...</span>  <span class="p">(</span><span class="nf">Point</span> <span class="mi">1</span> <span class="nv">x</span><span class="p">)</span> <span class="ss">:if</span> <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">%</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">x</span>
<span class="mi">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="defclass">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">defclass</span></code>  <em><span class="n"><span class="pre">class-name</span></span></em> <em><span class="n"><span class="pre">super-classes</span></span></em> <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">body</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#defclass" title="Permalink to this definition">¶</a></dt>
<dd><p>New classes are declared with <code class="docutils literal notranslate"><span class="pre">defclass</span></code>. It can take optional parameters in the following order:
a list defining (a) possible super class(es) and a string (<a class="reference external" href="https://docs.python.org/3/glossary.html#term-docstring" title="(in Python v3.9)"><span>docstring</span></a>).</p>
<p><strong>Examples</strong></p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">defclass</span> <span class="nv">class-name</span> <span class="p">[</span><span class="nv">super-class-1</span> <span class="nv">super-class-2</span><span class="p">]</span>
<span class="nv">...</span>   <span class="s">&quot;docstring&quot;</span>
<span class="nv">...</span>
<span class="nv">...</span>   <span class="p">(</span><span class="nf">setv</span> <span class="nv">attribute1</span> <span class="nv">value1</span><span class="p">)</span>
<span class="nv">...</span>   <span class="p">(</span><span class="nf">setv</span> <span class="nv">attribute2</span> <span class="nv">value2</span><span class="p">)</span>
<span class="nv">...</span>
<span class="nv">...</span>   <span class="p">(</span><span class="kd">defn </span><span class="nv">method</span> <span class="p">[</span><span class="nv">self</span><span class="p">]</span> <span class="p">(</span><span class="nb">print </span><span class="s">&quot;hello!&quot;</span><span class="p">)))</span>
</pre></div>
</div>
<p>Both values and functions can be bound on the new class as shown by the example
below:</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">defclass</span> <span class="nv">Cat</span> <span class="p">[]</span>
<span class="nv">...</span>  <span class="p">(</span><span class="nf">setv</span> <span class="nv">age</span> <span class="nv">None</span><span class="p">)</span>
<span class="nv">...</span>  <span class="p">(</span><span class="nf">setv</span> <span class="nv">colour</span> <span class="s">&quot;white&quot;</span><span class="p">)</span>
<span class="nv">...</span>
<span class="nv">...</span>  <span class="p">(</span><span class="kd">defn </span><span class="nv">speak</span> <span class="p">[</span><span class="nv">self</span><span class="p">]</span> <span class="p">(</span><span class="nb">print </span><span class="s">&quot;Meow&quot;</span><span class="p">)))</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">setv</span> <span class="nv">spot</span> <span class="p">(</span><span class="nf">Cat</span><span class="p">))</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">setv</span> <span class="nv">spot.colour</span> <span class="s">&quot;Black&quot;</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">.speak</span> <span class="nv">spot</span><span class="p">)</span>
<span class="nv">Meow</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="del">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">del</span></code>  <em><span class="n"><span class="pre">object</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#del" title="Permalink to this definition">¶</a></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 0.9.12.</span></p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">del</span></code> removes an object from the current namespace.</p>
<p><strong>Examples</strong></p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span>=&gt; (setv foo 42)
=&gt; (del foo)
=&gt; foo
Traceback (most recent call last):
  File &quot;&lt;console&gt;&quot;, line 1, in &lt;module&gt;
NameError: name &#39;foo&#39; is not defined
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">del</span></code> can also remove objects from mappings, lists, and more.</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">setv</span> <span class="nb">test </span><span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">)))</span>
<span class="nv">=&gt;</span> <span class="nv">test</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">]</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">del</span> <span class="p">(</span><span class="nf">cut</span> <span class="nb">test </span><span class="mi">2</span> <span class="mi">4</span><span class="p">))</span> <span class="c1">;; remove items from 2 to 4 excluded</span>
<span class="nv">=&gt;</span> <span class="nv">test</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">]</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">setv</span> <span class="nv">dic</span> <span class="p">{</span><span class="s">&quot;foo&quot;</span> <span class="s">&quot;bar&quot;</span><span class="p">})</span>
<span class="nv">=&gt;</span> <span class="nv">dic</span>
<span class="p">{</span><span class="s">&quot;foo&quot;</span> <span class="s">&quot;bar&quot;</span><span class="p">}</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">del</span> <span class="p">(</span><span class="nb">get </span><span class="nv">dic</span> <span class="s">&quot;foo&quot;</span><span class="p">))</span>
<span class="nv">=&gt;</span> <span class="nv">dic</span>
<span class="p">{}</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="nonlocal">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">nonlocal</span></code>  <em><span class="n"><span class="pre">object</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#nonlocal" title="Permalink to this definition">¶</a></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 0.11.1.</span></p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">nonlocal</span></code> can be used to mark a symbol as not local to the current scope.
The parameters are the names of symbols to mark as nonlocal.  This is necessary
to modify variables through nested <code class="docutils literal notranslate"><span class="pre">fn</span></code> scopes:</p>
<p><strong>Examples</strong></p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kd">defn </span><span class="nv">some-function</span> <span class="p">[]</span>
  <span class="p">(</span><span class="nf">setv</span> <span class="nv">x</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">register-some-callback</span>
    <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">stuff</span><span class="p">]</span>
      <span class="p">(</span><span class="nf">nonlocal</span> <span class="nv">x</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">setv</span> <span class="nv">x</span> <span class="nv">stuff</span><span class="p">))))</span>
</pre></div>
</div>
<p>Without the call to <code class="docutils literal notranslate"><span class="pre">(nonlocal</span> <span class="pre">x)</span></code>, the inner function would redefine <code class="docutils literal notranslate"><span class="pre">x</span></code> to
<code class="docutils literal notranslate"><span class="pre">stuff</span></code> inside its local scope instead of overwriting the <code class="docutils literal notranslate"><span class="pre">x</span></code> in the outer
function.</p>
<p>See <a class="reference external" href="https://www.python.org/dev/peps/pep-3104/">PEP3104</a> for further
information.</p>
</dd></dl>

<dl class="hy function">
<dt id="py">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">py</span></code>  <em><span class="n"><span class="pre">string</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#py" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">py</span></code> parses the given Python code at compile-time and inserts the result into
the generated abstract syntax tree. Thus, you can mix Python code into a Hy
program. Only a Python expression is allowed, not statements; use
<a class="reference internal" href="#pys" title="pys"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">pys</span></code></a> if you want to use Python statements. The value of the
expression is returned from the <code class="docutils literal notranslate"><span class="pre">py</span></code> form.</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">print </span><span class="s">&quot;A result from Python:&quot;</span> <span class="p">(</span><span class="nf">py</span> <span class="s">&quot;&#39;hello&#39; + &#39;world&#39;&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>The code must be given as a single string literal, but you can still use
macros, <a class="reference internal" href="#hy.eval" title="hy.eval"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">hy.eval</span></code></a>, and related tools to construct the <code class="docutils literal notranslate"><span class="pre">py</span></code> form. If
having to backslash-escape internal double quotes is getting you down, try a
<a class="reference internal" href="language/syntax.html#syntax-bracket-strings"><span class="std std-ref">bracket string</span></a>. If you want to evaluate some
Python code that’s only defined at run-time, try the standard Python function
<a class="reference external" href="https://docs.python.org/3.10/library/functions.html#eval" title="(in Python v3.10)"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a>.</p>
<p>Python code need not syntactically round-trip if you use <code class="docutils literal notranslate"><span class="pre">hy2py</span></code> on a Hy
program that uses <code class="docutils literal notranslate"><span class="pre">py</span></code> or <code class="docutils literal notranslate"><span class="pre">pys</span></code>. For example, comments will be removed.</p>
<span class="target" id="pys-specialform"></span></dd></dl>

<dl class="hy function">
<dt id="pys">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">pys</span></code>  <em><span class="n"><span class="pre">string</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#pys" title="Permalink to this definition">¶</a></dt>
<dd><p>As <a class="reference internal" href="#py" title="py"><code class="xref hy hy-func docutils literal notranslate"><span class="pre">py</span></code></a>, but the code can consist of zero or more statements,
including compound statements such as <code class="docutils literal notranslate"><span class="pre">for</span></code> and <code class="docutils literal notranslate"><span class="pre">def</span></code>. <code class="docutils literal notranslate"><span class="pre">pys</span></code> always
returns <code class="docutils literal notranslate"><span class="pre">None</span></code>. Also, the code string is dedented with
<a class="reference external" href="https://docs.python.org/3.10/library/textwrap.html#textwrap.dedent" title="(in Python v3.10)"><code class="xref py py-func docutils literal notranslate"><span class="pre">textwrap.dedent()</span></code></a> before parsing, which allows you to intend the code to
match the surrounding Hy code, but significant leading whitespace in embedded
string literals will be removed.</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">pys</span> <span class="s">&quot;myvar = 5&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nb">print </span><span class="s">&quot;myvar is&quot;</span> <span class="nv">myvar</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="quasiquote">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">quasiquote</span></code>  <em><span class="n"><span class="pre">form</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#quasiquote" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">quasiquote</span></code> allows you to quote a form, but also selectively evaluate
expressions. Expressions inside a <code class="docutils literal notranslate"><span class="pre">quasiquote</span></code> can be selectively evaluated
using <code class="docutils literal notranslate"><span class="pre">unquote</span></code> (<code class="docutils literal notranslate"><span class="pre">~</span></code>). The evaluated form can also be spliced using
<code class="docutils literal notranslate"><span class="pre">unquote-splice</span></code> (<code class="docutils literal notranslate"><span class="pre">~&#64;</span></code>). Quasiquote can be also written using the backquote
(<code class="docutils literal notranslate"><span class="pre">`</span></code>) symbol.</p>
<p><strong>Examples</strong></p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="c1">;; let `qux&#39; be a variable with value (bar baz)</span>
<span class="o">`</span><span class="p">(</span><span class="nf">foo</span> <span class="o">~</span><span class="nv">qux</span><span class="p">)</span>
<span class="c1">; equivalent to &#39;(foo (bar baz))</span>
<span class="o">`</span><span class="p">(</span><span class="nf">foo</span> <span class="o">~@</span><span class="nv">qux</span><span class="p">)</span>
<span class="c1">; equivalent to &#39;(foo bar baz)</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="quote">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">quote</span></code>  <em><span class="n"><span class="pre">form</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#quote" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">quote</span></code> returns the form passed to it without evaluating it. <code class="docutils literal notranslate"><span class="pre">quote</span></code> can
alternatively be written using the apostrophe (<code class="docutils literal notranslate"><span class="pre">'</span></code>) symbol.</p>
<p><strong>Examples</strong></p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">setv</span> <span class="nv">x</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">print </span><span class="s">&quot;Hello World&quot;</span><span class="p">))</span>
<span class="nv">=&gt;</span> <span class="nv">x</span>  <span class="c1">; variable x is set to unevaluated expression</span>
<span class="nv">hy.models.Expression</span><span class="p">([</span>
  <span class="nv">hy.models.Symbol</span><span class="p">(</span><span class="ss">&#39;print</span><span class="o">&#39;</span><span class="p">)</span>,
  <span class="nv">hy.models.String</span><span class="p">(</span><span class="ss">&#39;Hello</span> <span class="nv">World</span><span class="o">&#39;</span><span class="p">)])</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">hy.eval</span> <span class="nv">x</span><span class="p">)</span>
<span class="nv">Hello</span> <span class="nv">World</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="require">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">require</span></code>  <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">args</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#require" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">require</span></code> is used to import macros from one or more given modules. It allows
parameters in all the same formats as <code class="docutils literal notranslate"><span class="pre">import</span></code>. The <code class="docutils literal notranslate"><span class="pre">require</span></code> form itself
produces no code in the final program: its effect is purely at compile-time, for
the benefit of macro expansion. Specifically, <code class="docutils literal notranslate"><span class="pre">require</span></code> imports each named
module and then makes each requested macro available in the current module.</p>
<p>The following are all equivalent ways to call a macro named <code class="docutils literal notranslate"><span class="pre">foo</span></code> in the module <code class="docutils literal notranslate"><span class="pre">mymodule</span></code>:</p>
<p><strong>Examples</strong></p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">require</span> <span class="nv">mymodule</span><span class="p">)</span>
<span class="p">(</span><span class="nf">mymodule.foo</span> <span class="mi">1</span><span class="p">)</span>

<span class="p">(</span><span class="nf">require</span> <span class="nv">mymodule</span> <span class="ss">:as</span> <span class="nv">M</span><span class="p">)</span>
<span class="p">(</span><span class="nf">M.foo</span> <span class="mi">1</span><span class="p">)</span>

<span class="p">(</span><span class="nf">require</span> <span class="nv">mymodule</span> <span class="p">[</span><span class="nv">foo</span><span class="p">])</span>
<span class="p">(</span><span class="nf">foo</span> <span class="mi">1</span><span class="p">)</span>

<span class="p">(</span><span class="nf">require</span> <span class="nv">mymodule</span> <span class="nv">*</span><span class="p">)</span>
<span class="p">(</span><span class="nf">foo</span> <span class="mi">1</span><span class="p">)</span>

<span class="p">(</span><span class="nf">require</span> <span class="nv">mymodule</span> <span class="p">[</span><span class="nv">foo</span> <span class="ss">:as</span> <span class="nv">bar</span><span class="p">])</span>
<span class="p">(</span><span class="nf">bar</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Macros that call macros</strong></p>
<p>One aspect of <code class="docutils literal notranslate"><span class="pre">require</span></code> that may be surprising is what happens when one
macro’s expansion calls another macro. Suppose <code class="docutils literal notranslate"><span class="pre">mymodule.hy</span></code> looks like this:</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kd">defmacro </span><span class="nv">repexpr</span> <span class="p">[</span><span class="nv">n</span> <span class="nv">expr</span><span class="p">]</span>
  <span class="c1">; Evaluate the expression n times</span>
  <span class="c1">; and collect the results in a list.</span>
  <span class="o">`</span><span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">_</span><span class="p">]</span> <span class="o">~</span><span class="nv">expr</span><span class="p">)</span> <span class="p">(</span><span class="nb">range </span><span class="o">~</span><span class="nv">n</span><span class="p">))))</span>

<span class="p">(</span><span class="kd">defmacro </span><span class="nv">foo</span> <span class="p">[</span><span class="nv">n</span><span class="p">]</span>
  <span class="o">`</span><span class="p">(</span><span class="nf">repexpr</span> <span class="o">~</span><span class="nv">n</span> <span class="p">(</span><span class="nf">input</span> <span class="s">&quot;Gimme some input: &quot;</span><span class="p">)))</span>
</pre></div>
</div>
<p>And then, in your main program, you write:</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">require</span> <span class="nv">mymodule</span> <span class="p">[</span><span class="nv">foo</span><span class="p">])</span>

<span class="p">(</span><span class="nb">print </span><span class="p">(</span><span class="nf">mymodule.foo</span> <span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
<p>Running this raises <code class="docutils literal notranslate"><span class="pre">NameError:</span> <span class="pre">name</span> <span class="pre">'repexpr'</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">defined</span></code>, even though
writing <code class="docutils literal notranslate"><span class="pre">(print</span> <span class="pre">(foo</span> <span class="pre">3))</span></code> in <code class="docutils literal notranslate"><span class="pre">mymodule</span></code> works fine. The trouble is that your
main program doesn’t have the macro <code class="docutils literal notranslate"><span class="pre">repexpr</span></code> available, since it wasn’t
imported (and imported under exactly that name, as opposed to a qualified name).
You could do <code class="docutils literal notranslate"><span class="pre">(require</span> <span class="pre">mymodule</span> <span class="pre">*)</span></code> or <code class="docutils literal notranslate"><span class="pre">(require</span> <span class="pre">mymodule</span> <span class="pre">[foo</span> <span class="pre">repexpr])</span></code>,
but a less error-prone approach is to change the definition of
<code class="docutils literal notranslate"><span class="pre">foo</span></code> to require whatever sub-macros it needs:</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="kd">defmacro </span><span class="nv">foo</span> <span class="p">[</span><span class="nv">n</span><span class="p">]</span>
  <span class="o">`</span><span class="p">(</span><span class="nf">do</span>
    <span class="p">(</span><span class="nf">require</span> <span class="nv">mymodule</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">mymodule.repexpr</span> <span class="o">~</span><span class="nv">n</span> <span class="p">(</span><span class="nf">input</span> <span class="s">&quot;Gimme some input: &quot;</span><span class="p">))))</span>
</pre></div>
</div>
<p>It’s wise to use <code class="docutils literal notranslate"><span class="pre">(require</span> <span class="pre">mymodule)</span></code> here rather than <code class="docutils literal notranslate"><span class="pre">(require</span> <span class="pre">mymodule</span>
<span class="pre">[repexpr])</span></code> to avoid accidentally shadowing a function named <code class="docutils literal notranslate"><span class="pre">repexpr</span></code> in
the main program.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Qualified macro names</strong></p>
<p>Note that in the current implementation, there’s a trick in qualified macro
names, like <code class="docutils literal notranslate"><span class="pre">mymodule.foo</span></code> and <code class="docutils literal notranslate"><span class="pre">M.foo</span></code> in the above example. These names
aren’t actually attributes of module objects; they’re just identifiers with
periods in them. In fact, <code class="docutils literal notranslate"><span class="pre">mymodule</span></code> and <code class="docutils literal notranslate"><span class="pre">M</span></code> aren’t defined by these
<code class="docutils literal notranslate"><span class="pre">require</span></code> forms, even at compile-time. None of this will hurt you unless try
to do introspection of the current module’s set of defined macros, which isn’t
really supported anyway.</p>
</div>
</dd></dl>

<dl class="hy function">
<dt id="return">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">return</span></code>  <em><span class="n"><span class="pre">object</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#return" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">return</span></code> compiles to a <a class="reference external" href="https://docs.python.org/3.10/reference/simple_stmts.html#return" title="(in Python v3.10)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">return</span></code></a> statement. It exits the
current function, returning its argument if provided with one or
<code class="docutils literal notranslate"><span class="pre">None</span></code> if not.</p>
<p><strong>Examples</strong></p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">f</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nb">for </span><span class="p">[</span><span class="nv">n</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">)]</span> <span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">n</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nf">return</span> <span class="nv">n</span><span class="p">))))</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">f</span> <span class="mf">3.9</span><span class="p">)</span>
<span class="mi">4</span>
</pre></div>
</div>
<p>Note that in Hy, <code class="docutils literal notranslate"><span class="pre">return</span></code> is necessary much less often than in Python,
since the last form of a function is returned automatically. Hence, an
explicit <code class="docutils literal notranslate"><span class="pre">return</span></code> is only necessary to exit a function early.</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">f</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">setv</span> <span class="nv">y</span> <span class="mi">10</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">f</span> <span class="mi">4</span><span class="p">)</span>
<span class="mi">14</span>
</pre></div>
</div>
<p>To get Python’s behavior of returning <code class="docutils literal notranslate"><span class="pre">None</span></code> when execution reaches
the end of a function, put <code class="docutils literal notranslate"><span class="pre">None</span></code> there yourself.</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">f</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">setv</span> <span class="nv">y</span> <span class="mi">10</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">None</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">print </span><span class="p">(</span><span class="nf">f</span> <span class="mi">4</span><span class="p">))</span>
<span class="nv">None</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="cut">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">cut</span></code>  <em><span class="pre">coll</span> <span class="pre">[start</span> <span class="pre">None]</span> <span class="pre">[stop</span> <span class="pre">None]</span> <span class="pre">[step</span> <span class="pre">None</span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#cut" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">cut</span></code> can be used to take a subset of a list and create a new list from it.
The form takes at least one parameter specifying the list to cut. Two
optional parameters can be used to give the start and end position of the
subset. If only one is given, it is taken as the <code class="docutils literal notranslate"><span class="pre">stop</span></code> value.
The third optional parameter is used to control the step stride between the elements.</p>
<p><code class="docutils literal notranslate"><span class="pre">cut</span></code> follows the same rules as its Python counterpart. Negative indices are
counted starting from the end of the list. Some example usage:</p>
<p><strong>Examples</strong></p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">setv</span> <span class="nv">collection</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">))</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">cut</span> <span class="nv">collection</span><span class="p">)</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">]</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">cut</span> <span class="nv">collection</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">cut</span> <span class="nv">collection</span> <span class="mi">2</span> <span class="mi">8</span><span class="p">)</span>
<span class="p">[</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span><span class="p">]</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">cut</span> <span class="nv">collection</span> <span class="mi">2</span> <span class="mi">8</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">[</span><span class="mi">2</span> <span class="mi">4</span> <span class="mi">6</span><span class="p">]</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">cut</span> <span class="nv">collection</span> <span class="mi">-4</span> <span class="mi">-2</span><span class="p">)</span>
<span class="p">[</span><span class="mi">6</span> <span class="mi">7</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="raise">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">raise</span></code>  <em><span class="pre">[</span><span class="n"><span class="pre">exception</span></span><span class="o"> </span><span class="default_value"><span class="pre">None</span></span><span class="pre">]</span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#raise" title="Permalink to this definition">¶</a></dt>
<dd><p>The <code class="docutils literal notranslate"><span class="pre">raise</span></code> form can be used to raise an <code class="docutils literal notranslate"><span class="pre">Exception</span></code> at
runtime. Example usage:</p>
<p><strong>Examples</strong></p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">raise</span><span class="p">)</span>
<span class="c1">; re-rase the last exception</span>

<span class="p">(</span><span class="nf">raise</span> <span class="nv">IOError</span><span class="p">)</span>
<span class="c1">; raise an IOError</span>

<span class="p">(</span><span class="nf">raise</span> <span class="p">(</span><span class="nf">IOError</span> <span class="s">&quot;foobar&quot;</span><span class="p">))</span>
<span class="c1">; raise an IOError(&quot;foobar&quot;)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">raise</span></code> can accept a single argument (an <code class="docutils literal notranslate"><span class="pre">Exception</span></code> class or instance)
or no arguments to re-raise the last <code class="docutils literal notranslate"><span class="pre">Exception</span></code>.</p>
</dd></dl>

<dl class="hy function">
<dt id="try">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">try</span></code>  <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">body</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#try" title="Permalink to this definition">¶</a></dt>
<dd><p>The <code class="docutils literal notranslate"><span class="pre">try</span></code> form is used to catch exceptions (<code class="docutils literal notranslate"><span class="pre">except</span></code>) and run cleanup
actions (<code class="docutils literal notranslate"><span class="pre">finally</span></code>).</p>
<p><strong>Examples</strong></p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">try</span>
  <span class="p">(</span><span class="nf">error-prone-function</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">another-error-prone-function</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">except</span> <span class="p">[</span><span class="nv">ZeroDivisionError</span><span class="p">]</span>
    <span class="p">(</span><span class="nb">print </span><span class="s">&quot;Division by zero&quot;</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">except</span> <span class="p">[[</span><span class="nv">IndexError</span> <span class="nv">KeyboardInterrupt</span><span class="p">]]</span>
    <span class="p">(</span><span class="nb">print </span><span class="s">&quot;Index error or Ctrl-C&quot;</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">except</span> <span class="p">[</span><span class="nv">e</span> <span class="nv">ValueError</span><span class="p">]</span>
    <span class="p">(</span><span class="nb">print </span><span class="s">&quot;ValueError:&quot;</span> <span class="p">(</span><span class="nf">repr</span> <span class="nv">e</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">except</span> <span class="p">[</span><span class="nv">e</span> <span class="p">[</span><span class="nv">TabError</span> <span class="nv">PermissionError</span> <span class="nv">ReferenceError</span><span class="p">]]</span>
    <span class="p">(</span><span class="nb">print </span><span class="s">&quot;Some sort of error:&quot;</span> <span class="p">(</span><span class="nf">repr</span> <span class="nv">e</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">else</span>
    <span class="p">(</span><span class="nb">print </span><span class="s">&quot;No errors&quot;</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">finally</span>
    <span class="p">(</span><span class="nb">print </span><span class="s">&quot;All done&quot;</span><span class="p">)))</span>
</pre></div>
</div>
<p>The first argument of <code class="docutils literal notranslate"><span class="pre">try</span></code> is its body, which can contain one or more forms.
Then comes any number of <code class="docutils literal notranslate"><span class="pre">except</span></code> clauses, then optionally an <code class="docutils literal notranslate"><span class="pre">else</span></code>
clause, then optionally a <code class="docutils literal notranslate"><span class="pre">finally</span></code> clause. If an exception is raised with a
matching <code class="docutils literal notranslate"><span class="pre">except</span></code> clause during the execution of the body, that <code class="docutils literal notranslate"><span class="pre">except</span></code>
clause will be executed. If no exceptions are raised, the <code class="docutils literal notranslate"><span class="pre">else</span></code> clause is
executed. The <code class="docutils literal notranslate"><span class="pre">finally</span></code> clause will be executed last regardless of whether an
exception was raised.</p>
<p>The return value of <code class="docutils literal notranslate"><span class="pre">try</span></code> is the last form of the <code class="docutils literal notranslate"><span class="pre">except</span></code> clause that was
run, or the last form of <code class="docutils literal notranslate"><span class="pre">else</span></code> if no exception was raised, or the <code class="docutils literal notranslate"><span class="pre">try</span></code>
body if there is no <code class="docutils literal notranslate"><span class="pre">else</span></code> clause.</p>
</dd></dl>

<dl class="hy data">
<dt id="unpack-iterable/unpack-mapping">
<code class="sig-name descname"><span class="pre">unpack-iterable/unpack-mapping</span></code><a class="headerlink" href="#unpack-iterable/unpack-mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>(Also known as the splat operator, star operator, argument expansion, argument
explosion, argument gathering, and varargs, among others…)</p>
<p><code class="docutils literal notranslate"><span class="pre">unpack-iterable</span></code> and <code class="docutils literal notranslate"><span class="pre">unpack-mapping</span></code> allow an iterable or mapping
object (respectively) to provide positional or keywords arguments
(respectively) to a function.</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">f</span> <span class="p">[</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">]</span> <span class="p">[</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">])</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">unpack-iterable</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">])</span> <span class="p">(</span><span class="nf">unpack-mapping</span> <span class="p">{</span><span class="s">&quot;c&quot;</span> <span class="mi">3</span> <span class="s">&quot;d&quot;</span> <span class="mi">4</span><span class="p">}))</span>
<span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">unpack-iterable</span></code> is usually written with the shorthand <code class="docutils literal notranslate"><span class="pre">#*</span></code>, and
<code class="docutils literal notranslate"><span class="pre">unpack-mapping</span></code> with <code class="docutils literal notranslate"><span class="pre">#**</span></code>.</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">f</span> <span class="o">#</span><span class="nb">* </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">]</span> <span class="o">#</span><span class="nv">**</span> <span class="p">{</span><span class="s">&quot;c&quot;</span> <span class="mi">3</span> <span class="s">&quot;d&quot;</span> <span class="mi">4</span><span class="p">})</span>
<span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
<p>Unpacking is allowed in a variety of contexts, and you can unpack
more than once in one expression (<span class="target" id="index-1"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-3132"><strong>PEP 3132</strong></a>, <span class="target" id="index-2"></span><a class="pep reference external" href="https://www.python.org/dev/peps/pep-0448"><strong>PEP 448</strong></a>).</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">setv</span> <span class="p">[</span><span class="nv">a</span> <span class="o">#</span><span class="nb">* </span><span class="nv">b</span> <span class="nv">c</span><span class="p">]</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">])</span>
<span class="nv">=&gt;</span> <span class="p">[</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span> <span class="p">[</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]</span> <span class="mi">5</span><span class="p">]</span>
<span class="nv">=&gt;</span> <span class="p">[</span><span class="o">#</span><span class="nb">* </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">]</span> <span class="o">#</span><span class="nb">* </span><span class="p">[</span><span class="mi">3</span> <span class="mi">4</span><span class="p">]]</span>
<span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]</span>
<span class="nv">=&gt;</span> <span class="p">{</span><span class="o">#</span><span class="nv">**</span> <span class="p">{</span><span class="mi">1</span> <span class="mi">2</span><span class="p">}</span> <span class="o">#</span><span class="nv">**</span> <span class="p">{</span><span class="mi">3</span> <span class="mi">4</span><span class="p">}}</span>
<span class="p">{</span><span class="mi">1</span> <span class="mi">2</span>  <span class="mi">3</span> <span class="mi">4</span><span class="p">}</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">f</span> <span class="o">#</span><span class="nb">* </span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">#</span><span class="nb">* </span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">#</span><span class="nv">**</span> <span class="p">{</span><span class="s">&quot;c&quot;</span> <span class="mi">3</span><span class="p">}</span> <span class="o">#</span><span class="nv">**</span> <span class="p">{</span><span class="s">&quot;d&quot;</span> <span class="mi">4</span><span class="p">})</span>
<span class="p">[</span><span class="mi">1</span> <span class="mi">2</span>  <span class="mi">3</span> <span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="unquote">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">unquote</span></code>  <em><span class="n"><span class="pre">symbol</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#unquote" title="Permalink to this definition">¶</a></dt>
<dd><p>Within a quasiquoted form, <code class="docutils literal notranslate"><span class="pre">unquote</span></code> forces evaluation of a symbol. <code class="docutils literal notranslate"><span class="pre">unquote</span></code>
is aliased to the tilde (<code class="docutils literal notranslate"><span class="pre">~</span></code>) symbol.</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">setv</span> <span class="nv">nickname</span> <span class="s">&quot;Cuddles&quot;</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">quasiquote</span> <span class="p">(</span><span class="nb">= </span><span class="nv">nickname</span> <span class="p">(</span><span class="nf">unquote</span> <span class="nv">nickname</span><span class="p">)))</span>
<span class="o">&#39;</span><span class="p">(</span><span class="nb">= </span><span class="nv">nickname</span> <span class="s">&quot;Cuddles&quot;</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="o">`</span><span class="p">(</span><span class="nb">= </span><span class="nv">nickname</span> <span class="o">~</span><span class="nv">nickname</span><span class="p">)</span>
<span class="o">&#39;</span><span class="p">(</span><span class="nb">= </span><span class="nv">nickname</span> <span class="s">&quot;Cuddles&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="unquote-splice">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">unquote-splice</span></code>  <em><span class="n"><span class="pre">symbol</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#unquote-splice" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">unquote-splice</span></code> forces the evaluation of a symbol within a quasiquoted form,
much like <code class="docutils literal notranslate"><span class="pre">unquote</span></code>. <code class="docutils literal notranslate"><span class="pre">unquote-splice</span></code> can be used when the symbol
being unquoted contains an iterable value, as it “splices” that iterable into
the quasiquoted form. <code class="docutils literal notranslate"><span class="pre">unquote-splice</span></code> can also be used when the value
evaluates to a false value such as <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">False</span></code>, or <code class="docutils literal notranslate"><span class="pre">0</span></code>, in which
case the value is treated as an empty list and thus does not splice anything
into the form. <code class="docutils literal notranslate"><span class="pre">unquote-splice</span></code> is aliased to the <code class="docutils literal notranslate"><span class="pre">~&#64;</span></code> syntax.</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">setv</span> <span class="nv">nums</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">])</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">quasiquote</span> <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">unquote-splice</span> <span class="nv">nums</span><span class="p">)))</span>
<span class="o">&#39;</span><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="o">`</span><span class="p">(</span><span class="nb">+ </span><span class="o">~@</span><span class="nv">nums</span><span class="p">)</span>
<span class="o">&#39;</span><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="o">`</span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="o">~@</span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nb">get </span><span class="nv">nums</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">nums</span><span class="p">)]</span>
<span class="o">&#39;</span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<p>Here, the last example evaluates to <code class="docutils literal notranslate"><span class="pre">('+'</span> <span class="pre">1</span> <span class="pre">2)</span></code>, since the condition
<code class="docutils literal notranslate"><span class="pre">(&lt;</span> <span class="pre">(nth</span> <span class="pre">nums</span> <span class="pre">0)</span> <span class="pre">0)</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, which makes this <code class="docutils literal notranslate"><span class="pre">if</span></code> expression
evaluate to <code class="docutils literal notranslate"><span class="pre">None</span></code>, because the <code class="docutils literal notranslate"><span class="pre">if</span></code> expression here does not have an
else clause. <code class="docutils literal notranslate"><span class="pre">unquote-splice</span></code> then evaluates this as an empty value,
leaving no effects on the list it is enclosed in, therefore resulting in
<code class="docutils literal notranslate"><span class="pre">('+'</span> <span class="pre">1</span> <span class="pre">2)</span></code>.</p>
</dd></dl>

<dl class="hy function">
<dt id="while">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">while</span></code>  <em><span class="n"><span class="pre">condition</span></span></em> <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">body</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#while" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">while</span></code> compiles to a <a class="reference external" href="https://docs.python.org/3.10/reference/compound_stmts.html#while" title="(in Python v3.10)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">while</span></code></a> statement. It is used to execute a
set of forms as long as a condition is met. The first argument to <code class="docutils literal notranslate"><span class="pre">while</span></code> is
the condition, and any remaining forms constitute the body. The following
example will output “Hello world!” to the screen indefinitely:</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">while</span> <span class="nv">True</span> <span class="p">(</span><span class="nb">print </span><span class="s">&quot;Hello world!&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>The last form of a <code class="docutils literal notranslate"><span class="pre">while</span></code> loop can be an <code class="docutils literal notranslate"><span class="pre">else</span></code> clause, which is executed
after the loop terminates, unless it exited abnormally (e.g., with <code class="docutils literal notranslate"><span class="pre">break</span></code>). So,</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">setv</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="nf">while</span> <span class="nv">x</span>
   <span class="p">(</span><span class="nb">print </span><span class="s">&quot;In body&quot;</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">-=</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">else</span>
     <span class="p">(</span><span class="nb">print </span><span class="s">&quot;In else&quot;</span><span class="p">)))</span>
</pre></div>
</div>
<p>prints</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">In</span> <span class="nv">body</span>
<span class="nv">In</span> <span class="nv">body</span>
<span class="nv">In</span> <span class="nv">else</span>
</pre></div>
</div>
<p>If you put a <code class="docutils literal notranslate"><span class="pre">break</span></code> or <code class="docutils literal notranslate"><span class="pre">continue</span></code> form in the condition of a <code class="docutils literal notranslate"><span class="pre">while</span></code>
loop, it will apply to the very same loop rather than an outer loop, even if
execution is yet to ever reach the loop body. (Hy compiles a <code class="docutils literal notranslate"><span class="pre">while</span></code> loop
with statements in its condition by rewriting it so that the condition is
actually in the body.) So,</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">for </span><span class="p">[</span><span class="nv">x</span> <span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
   <span class="p">(</span><span class="nb">print </span><span class="s">&quot;In outer loop&quot;</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">while</span>
     <span class="p">(</span><span class="nf">do</span>
       <span class="p">(</span><span class="nb">print </span><span class="s">&quot;In condition&quot;</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">break</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">print </span><span class="s">&quot;This won&#39;t print.&quot;</span><span class="p">)</span>
       <span class="nv">True</span><span class="p">)</span>
     <span class="p">(</span><span class="nb">print </span><span class="s">&quot;This won&#39;t print, either.&quot;</span><span class="p">))</span>
   <span class="p">(</span><span class="nb">print </span><span class="s">&quot;At end of outer loop&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>prints</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">In</span> <span class="nv">outer</span> <span class="nv">loop</span>
<span class="nv">In</span> <span class="nv">condition</span>
<span class="nv">At</span> <span class="nv">end</span> <span class="nv">of</span> <span class="nv">outer</span> <span class="nv">loop</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="with">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">with</span></code>  <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">args</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#with" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrap execution of <cite>body</cite> within a context manager given as bracket <cite>args</cite>.
<code class="docutils literal notranslate"><span class="pre">with</span></code> is used to wrap the execution of a block within a context manager. The
context manager can then set up the local system and tear it down in a controlled
manner. The archetypical example of using <code class="docutils literal notranslate"><span class="pre">with</span></code> is when processing files.
If only a single expression is supplied, or the argument is <cite>_</cite>, then no
variable is bound to the expression, as shown below.</p>
<dl>
<dt>Examples:</dt><dd><div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">with</span> <span class="p">[</span><span class="nv">arg</span> <span class="p">(</span><span class="nf">expr</span><span class="p">)]</span> <span class="nv">block</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">with</span> <span class="p">[(</span><span class="nf">expr</span><span class="p">)]</span> <span class="nv">block</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">with</span> <span class="p">[</span><span class="nv">arg1</span> <span class="p">(</span><span class="nf">expr1</span><span class="p">)</span>  <span class="nv">_</span> <span class="p">(</span><span class="nf">expr2</span><span class="p">)</span>  <span class="nv">arg3</span> <span class="p">(</span><span class="nf">expr3</span><span class="p">)]</span> <span class="nv">block</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
<p>The following example will open the <code class="docutils literal notranslate"><span class="pre">NEWS</span></code> file and print its content to the
screen. The file is automatically closed after it has been processed:</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">with</span> <span class="p">[</span><span class="nv">f</span> <span class="p">(</span><span class="nf">open</span> <span class="sc">\&quot;</span><span class="nv">NEWS</span><span class="sc">\&quot;</span><span class="p">)]</span> <span class="p">(</span><span class="nb">print </span><span class="p">(</span><span class="nf">.read</span> <span class="nv">f</span><span class="p">)))</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">with</span></code> returns the value of its last form, unless it suppresses an exception
(because the context manager’s <code class="docutils literal notranslate"><span class="pre">__exit__</span></code> method returned true), in which
case it returns <code class="docutils literal notranslate"><span class="pre">None</span></code>. So, the previous example could also be written:</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">print </span><span class="p">(</span><span class="nf">with</span> <span class="p">[</span><span class="nv">f</span> <span class="p">(</span><span class="nf">open</span> <span class="sc">\&quot;</span><span class="nv">NEWS</span><span class="sc">\&quot;</span><span class="p">)]</span> <span class="p">(</span><span class="nf">.read</span> <span class="nv">f</span><span class="p">)))</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="with/a">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">with/a</span></code>  <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">args</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#with/a" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrap execution of <cite>body</cite> within a context manager given as bracket <cite>args</cite>.
<code class="docutils literal notranslate"><span class="pre">with/a</span></code> behaves like <code class="docutils literal notranslate"><span class="pre">with</span></code>, but is used to wrap the execution of a block
within an asynchronous context manager. The context manager can then set up
the local system and tear it down in a controlled manner asynchronously.
Examples:</p>
<blockquote>
<div><dl class="simple">
<dt>::</dt><dd><p>=&gt; (with/a [arg (expr)] block)
=&gt; (with/a [(expr)] block)
=&gt; (with/a [_ (expr)  arg (expr)  _ (expr)] block)</p>
</dd>
</dl>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">with/a</span></code> returns the value of its last form, unless it suppresses an exception
(because the context manager’s <code class="docutils literal notranslate"><span class="pre">__aexit__</span></code> method returned true), in which
case it returns <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</div>
</dd></dl>

<dl class="hy function">
<dt id="with-decorator">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">with-decorator</span></code>  <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">args</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#with-decorator" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">with-decorator</span></code> is used to wrap a function with another. The function
performing the decoration should accept a single value: the function being
decorated, and return a new function. <code class="docutils literal notranslate"><span class="pre">with-decorator</span></code> takes a minimum
of two parameters: the function performing decoration and the function
being decorated. More than one decorator function can be applied; they
will be applied in order from outermost to innermost, ie. the first
decorator will be the outermost one, and so on. Decorators with arguments
are called just like a function call.</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">with-decorator</span> <span class="nv">decorator-fun</span>
   <span class="p">(</span><span class="kd">defn </span><span class="nv">some-function</span> <span class="p">[]</span> <span class="nv">...</span><span class="p">)</span>

<span class="p">(</span><span class="nf">with-decorator</span> <span class="nv">decorator1</span> <span class="nv">decorator2</span> <span class="nv">...</span>
   <span class="p">(</span><span class="kd">defn </span><span class="nv">some-function</span> <span class="p">[]</span> <span class="nv">...</span><span class="p">)</span>

<span class="p">(</span><span class="nf">with-decorator</span> <span class="p">(</span><span class="nf">decorator</span> <span class="nv">arg</span><span class="p">)</span> <span class="nv">..</span>
   <span class="p">(</span><span class="kd">defn </span><span class="nv">some-function</span> <span class="p">[]</span> <span class="nv">...</span><span class="p">)</span>
</pre></div>
</div>
<p>In the following example, <code class="docutils literal notranslate"><span class="pre">inc-decorator</span></code> is used to decorate the function
<code class="docutils literal notranslate"><span class="pre">addition</span></code> with a function that takes two parameters and calls the
decorated function with values that are incremented by 1. When
the decorated <code class="docutils literal notranslate"><span class="pre">addition</span></code> is called with values 1 and 1, the end result
will be 4 (<code class="docutils literal notranslate"><span class="pre">1+1</span> <span class="pre">+</span> <span class="pre">1+1</span></code>).</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">inc-decorator</span> <span class="p">[</span><span class="nv">func</span><span class="p">]</span>
<span class="nv">...</span>  <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">value-1</span> <span class="nv">value-2</span><span class="p">]</span> <span class="p">(</span><span class="nf">func</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">value-1</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">value-2</span> <span class="mi">1</span><span class="p">))))</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">inc2-decorator</span> <span class="p">[</span><span class="nv">func</span><span class="p">]</span>
<span class="nv">...</span>  <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">value-1</span> <span class="nv">value-2</span><span class="p">]</span> <span class="p">(</span><span class="nf">func</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">value-1</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">value-2</span> <span class="mi">2</span><span class="p">))))</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">with-decorator</span> <span class="nv">inc-decorator</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">addition</span> <span class="p">[</span><span class="nv">a</span> <span class="nv">b</span><span class="p">]</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">addition</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">4</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">with-decorator</span> <span class="nv">inc2-decorator</span> <span class="nv">inc-decorator</span>
<span class="nv">...</span>  <span class="p">(</span><span class="kd">defn </span><span class="nv">addition</span> <span class="p">[</span><span class="nv">a</span> <span class="nv">b</span><span class="p">]</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">addition</span> <span class="mi">1</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">8</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="yield">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">yield</span></code>  <em><span class="n"><span class="pre">object</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#yield" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">yield</span></code> is used to create a generator object that returns one or more values.
The generator is iterable and therefore can be used in loops, list
comprehensions and other similar constructs.</p>
<p>The function <code class="docutils literal notranslate"><span class="pre">random-numbers</span></code> shows how generators can be used to generate
infinite series without consuming infinite amount of memory.</p>
<p><strong>Examples</strong></p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">multiply</span> <span class="p">[</span><span class="nv">bases</span> <span class="nv">coefficients</span><span class="p">]</span>
<span class="nv">...</span>  <span class="p">(</span><span class="nb">for </span><span class="p">[(</span>, <span class="nv">base</span> <span class="nv">coefficient</span><span class="p">)</span> <span class="p">(</span><span class="nf">zip</span> <span class="nv">bases</span> <span class="nv">coefficients</span><span class="p">)]</span>
<span class="nv">...</span>   <span class="p">(</span><span class="nf">yield</span> <span class="p">(</span><span class="nb">* </span><span class="nv">base</span> <span class="nv">coefficient</span><span class="p">))))</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">multiply</span> <span class="p">(</span><span class="nb">range </span><span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="nb">range </span><span class="mi">5</span><span class="p">))</span>
<span class="nv">&lt;generator</span> <span class="nv">object</span> <span class="nv">multiply</span> <span class="nv">at</span> <span class="mi">0</span><span class="nv">x978d8ec&gt;</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nf">multiply</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">)</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">)))</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">4</span> <span class="mi">9</span> <span class="mi">16</span> <span class="mi">25</span> <span class="mi">36</span> <span class="mi">49</span> <span class="mi">64</span> <span class="mi">81</span><span class="p">]</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">import </span><span class="nv">random</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">random-numbers</span> <span class="p">[</span><span class="nv">low</span> <span class="nv">high</span><span class="p">]</span>
<span class="nv">...</span>  <span class="p">(</span><span class="nf">while</span> <span class="nv">True</span> <span class="p">(</span><span class="nf">yield</span> <span class="p">(</span><span class="nf">.randint</span> <span class="nv">random</span> <span class="nv">low</span> <span class="nv">high</span><span class="p">))))</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">take </span><span class="mi">15</span> <span class="p">(</span><span class="nf">random-numbers</span> <span class="mi">1</span> <span class="mi">50</span><span class="p">)))</span>
<span class="p">[</span><span class="mi">7</span> <span class="mi">41</span> <span class="mi">6</span> <span class="mi">22</span> <span class="mi">32</span> <span class="mi">17</span> <span class="mi">5</span> <span class="mi">38</span> <span class="mi">18</span> <span class="mi">38</span> <span class="mi">17</span> <span class="mi">14</span> <span class="mi">23</span> <span class="mi">23</span> <span class="mi">19</span><span class="p">]</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="yield-from">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-name descname"><span class="pre">yield-from</span></code>  <em><span class="n"><span class="pre">object</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#yield-from" title="Permalink to this definition">¶</a></dt>
<dd><div class="versionadded">
<p><span class="versionmodified added">New in version 0.9.13.</span></p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">yield-from</span></code> is used to call a subgenerator.  This is useful if you
want your coroutine to be able to delegate its processes to another
coroutine, say, if using something fancy like
<a class="reference external" href="https://docs.python.org/3.4/library/asyncio.html">asyncio</a>.</p>
</dd></dl>

<span class="target" id="module-hy.core.macros"></span><dl class="hy macro">
<dt id="hy.core.macros.#&#64;">
<em class="property"><span class="pre">macro</span></em><code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.core.macros.</span></code><code class="sig-name descname"><span class="pre">#&#64;</span></code>  <em><span class="n"><span class="pre">expr</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.core.macros.#@" title="Permalink to this definition">¶</a></dt>
<dd><p>with-decorator tag macro</p>
</dd></dl>

<dl class="hy macro">
<dt id="hy.core.macros.cond">
<em class="property"><span class="pre">macro</span></em><code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.core.macros.</span></code><code class="sig-name descname"><span class="pre">cond</span></code>  <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">branches</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.core.macros.cond" title="Permalink to this definition">¶</a></dt>
<dd><p>Build a nested if clause with each <cite>branch</cite> a [cond result] bracket pair.</p>
<p class="rubric">Examples</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">cond </span><span class="p">[</span><span class="nv">condition-1</span> <span class="nv">result-1</span><span class="p">]</span>
<span class="nv">...</span>      <span class="p">[</span><span class="nv">condition-2</span> <span class="nv">result-2</span><span class="p">])</span>
<span class="p">(</span><span class="k">if </span><span class="nv">condition-1</span> <span class="nv">result-1</span>
  <span class="p">(</span><span class="k">if </span><span class="nv">condition-2</span> <span class="nv">result-2</span><span class="p">))</span>
</pre></div>
</div>
<p>If only the condition is given in a branch, then the condition is also used as
the result. The expansion of this single argument version is demonstrated
below:</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">cond </span><span class="p">[</span><span class="nv">condition-1</span><span class="p">]</span>
<span class="nv">...</span>       <span class="p">[</span><span class="nv">condition-2</span><span class="p">])</span>
<span class="p">(</span><span class="k">if </span><span class="nv">condition-1</span> <span class="nv">condition-1</span>
  <span class="p">(</span><span class="k">if </span><span class="nv">condition-2</span> <span class="nv">condition-2</span><span class="p">))</span>
</pre></div>
</div>
<p>As shown below, only the first matching result block is executed:</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">check-value</span> <span class="p">[</span><span class="nv">value</span><span class="p">]</span>
<span class="nv">...</span>   <span class="p">(</span><span class="nb">cond </span><span class="p">[(</span><span class="nb">&lt; </span><span class="nv">value</span> <span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="nb">print </span><span class="s">&quot;value is smaller than 5&quot;</span><span class="p">)]</span>
<span class="nv">...</span>         <span class="p">[(</span><span class="nb">= </span><span class="nv">value</span> <span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="nb">print </span><span class="s">&quot;value is equal to 5&quot;</span><span class="p">)]</span>
<span class="nv">...</span>         <span class="p">[(</span><span class="nb">&gt; </span><span class="nv">value</span> <span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="nb">print </span><span class="s">&quot;value is greater than 5&quot;</span><span class="p">)]</span>
<span class="nv">...</span>         <span class="p">[</span><span class="nv">True</span> <span class="p">(</span><span class="nb">print </span><span class="s">&quot;value is something that it should not be&quot;</span><span class="p">)]))</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">check-value</span> <span class="mi">6</span><span class="p">)</span>
<span class="s">&quot;value is greater than 5&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy macro">
<dt id="hy.core.macros.doc">
<em class="property"><span class="pre">macro</span></em><code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.core.macros.</span></code><code class="sig-name descname"><span class="pre">doc</span></code>  <em><span class="n"><span class="pre">symbol</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.core.macros.doc" title="Permalink to this definition">¶</a></dt>
<dd><p>macro documentation</p>
<p>Gets help for a macro function available in this module.
Use <code class="docutils literal notranslate"><span class="pre">require</span></code> to make other macros available.</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">(help</span> <span class="pre">foo)</span></code> instead for help with runtime objects.</p>
</dd></dl>

<dl class="hy macro">
<dt id="hy.core.macros.when">
<em class="property"><span class="pre">macro</span></em><code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.core.macros.</span></code><code class="sig-name descname"><span class="pre">when</span></code>  <em><span class="n"><span class="pre">test</span></span></em> <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">body</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.core.macros.when" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute <cite>body</cite> when <cite>test</cite> is true</p>
<p><code class="docutils literal notranslate"><span class="pre">when</span></code> is similar to <code class="docutils literal notranslate"><span class="pre">unless</span></code>, except it tests when the given conditional is
<code class="docutils literal notranslate"><span class="pre">True</span></code>. It is not possible to have an <code class="docutils literal notranslate"><span class="pre">else</span></code> block in a <code class="docutils literal notranslate"><span class="pre">when</span></code> macro. The
following shows the expansion of the macro.</p>
<p class="rubric">Examples</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">when </span><span class="nv">conditional</span> <span class="nv">statement</span><span class="p">)</span>
<span class="p">(</span><span class="k">if </span><span class="nv">conditional</span> <span class="p">(</span><span class="k">do </span><span class="nv">statement</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="placeholder-macros">
<h3>Placeholder macros<a class="headerlink" href="#placeholder-macros" title="Permalink to this headline">¶</a></h3>
<p>There are a few core macros that are unusual in that all they do, when
expanded, is crash, regardless of their arguments:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">else</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">except</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">finally</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">unpack-mapping</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">unquote</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">unquote-splice</span></code></p></li>
</ul>
<p>The purpose of these macros is merely to reserve their names. Each
symbol is interpreted specially by one or more other core macros
(e.g., <code class="docutils literal notranslate"><span class="pre">else</span></code> in <code class="docutils literal notranslate"><span class="pre">while</span></code>) and thus, in these contexts, any
definition of these names as a function or macro would be ignored. If
you really want to, you can override these names like any others, but
beware that, for example, trying to call your new <code class="docutils literal notranslate"><span class="pre">else</span></code> inside
<code class="docutils literal notranslate"><span class="pre">while</span></code> may not work.</p>
</div>
</div>
<div class="section" id="hy">
<h2>Hy<a class="headerlink" href="#hy" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">hy</span></code> module is auto imported into every Hy module and provides convient access to
the following methods</p>
<dl class="hy function">
<dt id="hy.read-str">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.</span></code><code class="sig-name descname"><span class="pre">read-str</span></code>  <em><span class="n"><span class="pre">input</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.read-str" title="Permalink to this definition">¶</a></dt>
<dd><p>This is essentially a wrapper around <code class="docutils literal notranslate"><span class="pre">hy.read</span></code> which reads expressions from a
string</p>
<p class="rubric">Examples</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">hy.read-str</span> <span class="s">&quot;(print 1)&quot;</span><span class="p">)</span>
<span class="o">&#39;</span><span class="p">(</span><span class="nb">print </span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">hy.eval</span> <span class="p">(</span><span class="nf">hy.read-str</span> <span class="s">&quot;(print 1)&quot;</span><span class="p">))</span>
<span class="mi">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="hy.read [ [from-file &lt;_io.TextIOWrapper name='&lt;stdin&gt;' mode='r' encoding='utf-8'&gt;]">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">read</span> <span class="pre">[</span> <span class="pre">[from-file</span> <span class="pre">&lt;_io.</span></code><code class="sig-name descname"><span class="pre">TextIOWrapper</span> <span class="pre">name='&lt;stdin&gt;'</span> <span class="pre">mode='r'</span> <span class="pre">encoding='utf-8'&gt;]</span></code>  <em><span class="pre">eof</span> <span class="pre">]</span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.read [ [from-file <_io.TextIOWrapper name='<stdin>' mode='r' encoding='utf-8'>]" title="Permalink to this definition">¶</a></dt>
<dd><p>Read from input and returns a tokenized string.</p>
<p>Can take a given input buffer to read from, and a single byte as EOF
(defaults to an empty string).</p>
<p>Reads the next Hy expression from <em>from-file</em> (defaulting to <code class="docutils literal notranslate"><span class="pre">sys.stdin</span></code>), and
can take a single byte as EOF (defaults to an empty string). Raises <code class="docutils literal notranslate"><span class="pre">EOFError</span></code>
if <em>from-file</em> ends before a complete expression can be parsed.</p>
<p class="rubric">Examples</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">hy.read</span><span class="p">)</span>
<span class="p">(</span><span class="nb">+ </span><span class="mi">2</span> <span class="mi">2</span><span class="p">)</span>
<span class="o">&#39;</span><span class="p">(</span><span class="nb">+ </span><span class="mi">2</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">hy.eval</span> <span class="p">(</span><span class="nf">hy.read</span><span class="p">))</span>
<span class="p">(</span><span class="nb">+ </span><span class="mi">2</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">4</span>
</pre></div>
</div>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">import </span><span class="nv">io</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">setv</span> <span class="nv">buffer</span> <span class="p">(</span><span class="nf">io.StringIO</span> <span class="s">&quot;(+ 2 2)\n(- 2 1)&quot;</span><span class="p">))</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">hy.eval</span> <span class="p">(</span><span class="nf">hy.read</span> <span class="ss">:from-file</span> <span class="nv">buffer</span><span class="p">))</span>
<span class="mi">4</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">hy.eval</span> <span class="p">(</span><span class="nf">hy.read</span> <span class="ss">:from-file</span> <span class="nv">buffer</span><span class="p">))</span>
<span class="mi">1</span>
</pre></div>
</div>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">with</span> <span class="p">[</span><span class="nv">f</span> <span class="p">(</span><span class="nf">open</span> <span class="s">&quot;example.hy&quot;</span> <span class="s">&quot;w&quot;</span><span class="p">)]</span>
<span class="nv">...</span>  <span class="p">(</span><span class="nf">.write</span> <span class="nv">f</span> <span class="s">&quot;(print &#39;hello)\n(print &quot;</span><span class="nv">hyfriends!</span><span class="s">&quot;)&quot;</span><span class="p">))</span>
<span class="mi">35</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">with</span> <span class="p">[</span><span class="nv">f</span> <span class="p">(</span><span class="nf">open</span> <span class="s">&quot;example.hy&quot;</span><span class="p">)]</span>
<span class="nv">...</span>  <span class="p">(</span><span class="nf">try</span> <span class="p">(</span><span class="nf">while</span> <span class="nv">True</span>
<span class="nv">...</span>         <span class="p">(</span><span class="nf">setv</span> <span class="nv">exp</span> <span class="p">(</span><span class="nf">hy.read</span> <span class="nv">f</span><span class="p">))</span>
<span class="nv">...</span>         <span class="p">(</span><span class="nb">print </span><span class="s">&quot;OHY&quot;</span> <span class="nv">exp</span><span class="p">)</span>
<span class="nv">...</span>         <span class="p">(</span><span class="nf">hy.eval</span> <span class="nv">exp</span><span class="p">))</span>
<span class="nv">...</span>       <span class="p">(</span><span class="nf">except</span> <span class="p">[</span><span class="nv">e</span> <span class="nv">EOFError</span><span class="p">]</span>
<span class="nv">...</span>         <span class="p">(</span><span class="nb">print </span><span class="s">&quot;EOF!&quot;</span><span class="p">))))</span>
<span class="nv">OHY</span> <span class="nv">hy.models.Expression</span><span class="p">([</span>
  <span class="nv">hy.models.Symbol</span><span class="p">(</span><span class="ss">&#39;print</span><span class="o">&#39;</span><span class="p">)</span>,
  <span class="nv">hy.models.Expression</span><span class="p">([</span>
    <span class="nv">hy.models.Symbol</span><span class="p">(</span><span class="ss">&#39;quote</span><span class="o">&#39;</span><span class="p">)</span>,
    <span class="nv">hy.models.Symbol</span><span class="p">(</span><span class="ss">&#39;hello</span><span class="o">&#39;</span><span class="p">)])])</span>
<span class="nv">hello</span>
<span class="nv">OHY</span> <span class="nv">hy.models.Expression</span><span class="p">([</span>
  <span class="nv">hy.models.Symbol</span><span class="p">(</span><span class="ss">&#39;print</span><span class="o">&#39;</span><span class="p">)</span>,
  <span class="nv">hy.models.String</span><span class="p">(</span><span class="ss">&#39;hyfriends!</span><span class="o">&#39;</span><span class="p">)])</span>
<span class="nv">hyfriends!</span>
<span class="nv">EOF!</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="hy.eval">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.</span></code><code class="sig-name descname"><span class="pre">eval</span></code>  <em><span class="n"><span class="pre">hytree</span></span></em> <em><span class="n"><span class="pre">locals</span></span></em> <em><span class="n"><span class="pre">module</span></span></em> <em><span class="n"><span class="pre">ast-callback</span></span></em> <em><span class="n"><span class="pre">compiler</span></span></em> <em><span class="n"><span class="pre">filename</span></span></em> <em><span class="n"><span class="pre">source</span></span></em> <em><span class="pre">[</span><span class="n"><span class="pre">import-stdlib</span></span><span class="o"> </span><span class="default_value"><span class="pre">True</span></span><span class="pre">]</span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates a quoted expression and returns the value.</p>
<p>If you’re evaluating hand-crafted AST trees, make sure the line numbers
are set properly.  Try <cite>fix_missing_locations</cite> and related functions in the
Python <cite>ast</cite> library.</p>
<p class="rubric">Examples</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">hy.eval</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">print </span><span class="s">&quot;Hello World&quot;</span><span class="p">))</span>
<span class="s">&quot;Hello World&quot;</span>
</pre></div>
</div>
<p>If you want to evaluate a string, use <code class="docutils literal notranslate"><span class="pre">read-str</span></code> to convert it to a
form first:</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">hy.eval</span> <span class="p">(</span><span class="nf">hy.read-str</span> <span class="s">&quot;(+ 1 1)&quot;</span><span class="p">))</span>
<span class="mi">2</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hytree</strong> (<em>Object</em>) – The Hy AST object to evaluate.</p></li>
<li><p><strong>locals</strong> (<em>Optional</em><em>[</em><em>dict</em><em>]</em>) – Local environment in which to evaluate the Hy tree.  Defaults to the
calling frame.</p></li>
<li><p><strong>module</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><em>str</em><em>, </em><em>types.ModuleType</em><em>]</em><em>]</em>) – Module, or name of the module, to which the Hy tree is assigned and
the global values are taken.
The module associated with <cite>compiler</cite> takes priority over this value.
When neither <cite>module</cite> nor <cite>compiler</cite> is specified, the calling frame’s
module is used.</p></li>
<li><p><strong>ast_callback</strong> (<em>Optional</em><em>[</em><em>Callable</em><em>]</em>) – A callback that is passed the Hy compiled tree and resulting
expression object, in that order, after compilation but before
evaluation.</p></li>
<li><p><strong>compiler</strong> (<em>Optional</em><em>[</em><em>HyASTCompiler</em><em>]</em>) – An existing Hy compiler to use for compilation.  Also serves as
the <cite>module</cite> value when given.</p></li>
<li><p><strong>filename</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – The filename corresponding to the source for <cite>tree</cite>.  This will be
overridden by the <cite>filename</cite> field of <cite>tree</cite>, if any; otherwise, it
defaults to “&lt;string&gt;”.  When <cite>compiler</cite> is given, its <cite>filename</cite> field
value is always used.</p></li>
<li><p><strong>source</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>) – A string containing the source code for <cite>tree</cite>.  This will be
overridden by the <cite>source</cite> field of <cite>tree</cite>, if any; otherwise,
if <cite>None</cite>, an attempt will be made to obtain it from the module given by
<cite>module</cite>.  When <cite>compiler</cite> is given, its <cite>source</cite> field value is always
used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Result of evaluating the Hy compiled tree.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Any</p>
</dd>
</dl>
</dd></dl>

<dl class="hy function">
<dt id="hy.repr">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.</span></code><code class="sig-name descname"><span class="pre">repr</span></code>  <em><span class="n"><span class="pre">obj</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.repr" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is Hy’s equivalent of Python’s built-in <code class="docutils literal notranslate"><span class="pre">repr</span></code>.
It returns a string representing the input object in Hy syntax.</p>
<p>Like <code class="docutils literal notranslate"><span class="pre">repr</span></code> in Python, <code class="docutils literal notranslate"><span class="pre">hy.repr</span></code> can round-trip many kinds of
values. Round-tripping implies that given an object <code class="docutils literal notranslate"><span class="pre">x</span></code>,
<code class="docutils literal notranslate"><span class="pre">(hy.eval</span> <span class="pre">(hy.read-str</span> <span class="pre">(hy.repr</span> <span class="pre">x)))</span></code> returns <code class="docutils literal notranslate"><span class="pre">x</span></code>, or at least a value
that’s equal to <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p class="rubric">Examples</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="nv">hy.repr</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="s">&quot;[1 2 3]&quot;</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">repr</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="s">&quot;[1, 2, 3]&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="hy.repr-register">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.</span></code><code class="sig-name descname"><span class="pre">repr-register</span></code>  <em><span class="n"><span class="pre">types</span></span></em> <em><span class="n"><span class="pre">f</span></span></em> <em><span class="n"><span class="pre">placeholder</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.repr-register" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">hy.repr-register</span></code> lets you set the function that <code class="docutils literal notranslate"><span class="pre">hy.repr</span></code> calls to
represent a type.</p>
<p class="rubric">Examples</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span> <span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">hy.repr-register</span> <span class="nv">the-type</span> <span class="nv">fun</span><span class="p">)</span>

 <span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">defclass</span> <span class="nv">C</span><span class="p">)</span>
 <span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">hy.repr-register</span> <span class="nv">C</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="s">&quot;cuddles&quot;</span><span class="p">))</span>
 <span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">hy.repr</span> <span class="p">[</span><span class="mi">1</span> <span class="p">(</span><span class="nf">C</span><span class="p">)</span> <span class="mi">2</span><span class="p">])</span>
 <span class="s">&quot;[1 cuddles 2]&quot;</span>

 <span class="nv">If</span> <span class="nv">the</span> <span class="nv">type</span> <span class="nv">of</span> <span class="nv">an</span> <span class="nv">object</span> <span class="nv">passed</span> <span class="nv">to</span> <span class="o">``</span><span class="nv">hy.repr</span><span class="o">``</span> <span class="nv">doesn</span><span class="ss">&#39;t</span> <span class="nv">have</span> <span class="nv">a</span> <span class="nv">registered</span>
 <span class="nv">function</span>, <span class="o">``</span><span class="nv">hy.repr</span><span class="o">``</span> <span class="nv">falls</span> <span class="nv">back</span> <span class="nv">on</span> <span class="o">``</span><span class="nv">repr</span><span class="o">``</span><span class="nv">.</span>

 <span class="nv">Registered</span> <span class="nv">functions</span> <span class="nv">often</span> <span class="nv">call</span> <span class="o">``</span><span class="nv">hy.repr</span><span class="o">``</span> <span class="nv">themselves.</span> <span class="o">``</span><span class="nv">hy.repr</span><span class="o">``</span> <span class="nv">will</span>
 <span class="nv">automatically</span> <span class="nv">detect</span> <span class="nv">self-references</span>, <span class="nv">even</span> <span class="nv">deeply</span> <span class="nv">nested</span> <span class="nv">ones</span>, <span class="nv">and</span>
 <span class="nv">output</span> <span class="o">``</span><span class="s">&quot;...&quot;</span><span class="o">``</span> <span class="nb">for </span><span class="nv">them</span> <span class="nv">instead</span> <span class="nv">of</span> <span class="nv">calling</span> <span class="nv">the</span> <span class="nv">usual</span> <span class="nv">registered</span>
 <span class="nv">function.</span> <span class="nv">To</span> <span class="nv">use</span> <span class="nv">a</span> <span class="nv">placeholder</span> <span class="nv">other</span> <span class="nv">than</span> <span class="o">``</span><span class="s">&quot;...&quot;</span><span class="o">``</span>, <span class="nv">pass</span> <span class="nv">a</span> <span class="nv">string</span> <span class="nv">of</span>
 <span class="nv">your</span> <span class="nv">choice</span> <span class="nv">to</span> <span class="nv">the</span> <span class="nb">keyword </span><span class="nv">argument</span> <span class="o">``</span><span class="ss">:placeholder</span><span class="o">``</span> <span class="nv">of</span>
 <span class="o">``</span><span class="nv">hy.repr-register</span><span class="o">``</span><span class="nv">.</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">defclass</span> <span class="nv">Container</span> <span class="p">[</span><span class="nv">object</span><span class="p">]</span>
<span class="nv">...</span>   <span class="p">(</span><span class="kd">defn </span><span class="nv">__init__</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">self</span> <span class="nv">value</span><span class="p">]</span>
<span class="nv">...</span>     <span class="p">(</span><span class="nf">setv</span> <span class="nv">self.value</span> <span class="nv">value</span><span class="p">))))</span>
<span class="nv">=&gt;</span>    <span class="p">(</span><span class="nf">hy.repr-register</span> <span class="nv">Container</span> <span class="ss">:placeholder</span> <span class="s">&quot;HY THERE&quot;</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span>
<span class="nv">...</span>      <span class="p">(</span><span class="nb">+ </span><span class="s">&quot;(Container &quot;</span> <span class="p">(</span><span class="nf">hy.repr</span> <span class="nv">x.value</span><span class="p">)</span> <span class="s">&quot;)&quot;</span><span class="p">)))</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">setv</span> <span class="nv">container</span> <span class="p">(</span><span class="nf">Container</span> <span class="mi">5</span><span class="p">))</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">setv</span> <span class="nv">container.value</span> <span class="nv">container</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">print </span><span class="p">(</span><span class="nf">hy.repr</span> <span class="nv">container</span><span class="p">))</span>
<span class="o">&#39;</span><span class="p">(</span><span class="nf">Container</span> <span class="nv">HY</span> <span class="nv">THERE</span><span class="p">)</span><span class="o">&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="hy.mangle">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.</span></code><code class="sig-name descname"><span class="pre">mangle</span></code>  <em><span class="n"><span class="pre">s</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.mangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Stringify the argument and convert it to a valid Python identifier
according to <a class="reference internal" href="language/syntax.html#mangling"><span class="std std-ref">Hy’s mangling rules</span></a>.</p>
<p class="rubric">Examples</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">hy.mangle</span> <span class="ss">&#39;foo-bar</span><span class="p">)</span>
<span class="s">&quot;foo_bar&quot;</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">hy.mangle</span> <span class="ss">&#39;foo-bar?</span><span class="p">)</span>
<span class="s">&quot;is_foo_bar&quot;</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">hy.mangle</span> <span class="ss">&#39;*</span><span class="p">)</span>
<span class="s">&quot;hyx_XasteriskX&quot;</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">hy.mangle</span> <span class="ss">&#39;_foo/a?</span><span class="p">)</span>
<span class="s">&quot;_hyx_is_fooXsolidusXa&quot;</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">hy.mangle</span> <span class="ss">&#39;--&gt;</span><span class="p">)</span>
<span class="s">&quot;hyx_XhyphenHminusX_XgreaterHthan_signX&quot;</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">hy.mangle</span> <span class="ss">&#39;&lt;--</span><span class="p">)</span>
<span class="s">&quot;hyx_XlessHthan_signX__&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="hy.unmangle">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.</span></code><code class="sig-name descname"><span class="pre">unmangle</span></code>  <em><span class="n"><span class="pre">s</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.unmangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Stringify the argument and try to convert it to a pretty unmangled
form. This may not round-trip, because different Hy symbol names can
mangle to the same Python identifier. See <a class="reference internal" href="language/syntax.html#mangling"><span class="std std-ref">Hy’s mangling rules</span></a>.</p>
<p class="rubric">Examples</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">hy.unmangle</span> <span class="ss">&#39;foo_bar</span><span class="p">)</span>
<span class="s">&quot;foo-bar&quot;</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">hy.unmangle</span> <span class="ss">&#39;is_foo_bar</span><span class="p">)</span>
<span class="s">&quot;foo-bar?&quot;</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">hy.unmangle</span> <span class="ss">&#39;hyx_XasteriskX</span><span class="p">)</span>
<span class="s">&quot;*&quot;</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">hy.unmangle</span> <span class="ss">&#39;_hyx_is_fooXsolidusXa</span><span class="p">)</span>
<span class="s">&quot;_foo/a?&quot;</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">hy.unmangle</span> <span class="ss">&#39;hyx_XhyphenHminusX_XgreaterHthan_signX</span><span class="p">)</span>
<span class="s">&quot;--&gt;&quot;</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">hy.unmangle</span> <span class="ss">&#39;hyx_XlessHthan_signX__</span><span class="p">)</span>
<span class="s">&quot;&lt;--&quot;</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">hy.unmangle</span> <span class="ss">&#39;__dunder_name__</span><span class="p">)</span>
<span class="s">&quot;__dunder-name__&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="hy.disassemble">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.</span></code><code class="sig-name descname"><span class="pre">disassemble</span></code>  <em><span class="n"><span class="pre">tree</span></span></em> <em><span class="pre">[</span><span class="n"><span class="pre">codegen</span></span><span class="o"> </span><span class="default_value"><span class="pre">False</span></span><span class="pre">]</span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.disassemble" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the python AST for a quoted Hy <cite>tree</cite> as a string.</p>
<p>If the second argument <cite>codegen</cite> is true, generate python code instead.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.10.0.</span></p>
</div>
<p>Dump the Python AST for given Hy <em>tree</em> to standard output. If <em>codegen</em>
is <code class="docutils literal notranslate"><span class="pre">True</span></code>, the function prints Python code instead.</p>
<p class="rubric">Examples</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">hy.disassemble</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">print </span><span class="s">&quot;Hello World!&quot;</span><span class="p">))</span>
<span class="nv">Module</span><span class="p">(</span>
 <span class="nv">body=</span><span class="p">[</span>
     <span class="nv">Expr</span><span class="p">(</span><span class="nf">value=Call</span><span class="p">(</span><span class="nf">func=Name</span><span class="p">(</span><span class="nf">id=</span><span class="ss">&#39;print</span><span class="o">&#39;</span><span class="p">)</span>, <span class="nv">args=</span><span class="p">[</span><span class="nv">Str</span><span class="p">(</span><span class="nf">s=</span><span class="ss">&#39;Hello</span> <span class="nv">World!</span><span class="o">&#39;</span><span class="p">)]</span>, <span class="nv">keywords=</span><span class="p">[]</span>, <span class="nv">starargs=None</span>, <span class="nv">kwargs=None</span><span class="p">))])</span>
</pre></div>
</div>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">hy.disassemble</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">print </span><span class="s">&quot;Hello World!&quot;</span><span class="p">)</span> <span class="nv">True</span><span class="p">)</span>
<span class="nv">print</span><span class="p">(</span><span class="ss">&#39;Hello</span> <span class="nv">World!</span><span class="o">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="hy.macroexpand">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.</span></code><code class="sig-name descname"><span class="pre">macroexpand</span></code>  <em><span class="n"><span class="pre">form</span></span></em> <em><span class="pre">[</span><span class="n"><span class="pre">result-ok</span></span><span class="o"> </span><span class="default_value"><span class="pre">False</span></span><span class="pre">]</span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.macroexpand" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the full macro expansion of <cite>form</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.10.0.</span></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">require</span> <span class="nv">hyrule</span> <span class="p">[</span><span class="nv">-&gt;</span><span class="p">])</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">hy.macroexpand</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">-&gt; </span><span class="p">(</span><span class="nf">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)))</span>
<span class="o">&#39;</span><span class="p">(</span><span class="nf">x</span> <span class="p">(</span><span class="nf">a</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">y</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">hy.macroexpand</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">-&gt; </span><span class="p">(</span><span class="nf">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nb">-&gt; </span><span class="p">(</span><span class="nf">c</span> <span class="nv">d</span><span class="p">)</span> <span class="p">(</span><span class="nf">e</span> <span class="nv">f</span><span class="p">))))</span>
<span class="o">&#39;</span><span class="p">(</span><span class="nf">e</span> <span class="p">(</span><span class="nf">c</span> <span class="p">(</span><span class="nf">a</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">d</span><span class="p">)</span> <span class="nv">f</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="hy.macroexpand-1">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.</span></code><code class="sig-name descname"><span class="pre">macroexpand-1</span></code>  <em><span class="n"><span class="pre">form</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.macroexpand-1" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the single step macro expansion of <cite>form</cite>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.10.0.</span></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">require</span> <span class="nv">hyrule</span> <span class="p">[</span><span class="nv">-&gt;</span><span class="p">])</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">hy.macroexpand-1</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">-&gt; </span><span class="p">(</span><span class="nf">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nb">-&gt; </span><span class="p">(</span><span class="nf">c</span> <span class="nv">d</span><span class="p">)</span> <span class="p">(</span><span class="nf">e</span> <span class="nv">f</span><span class="p">))))</span>
<span class="o">&#39;</span><span class="p">(</span><span class="nb">-&gt; </span><span class="p">(</span><span class="nf">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nf">c</span> <span class="nv">d</span><span class="p">)</span> <span class="p">(</span><span class="nf">e</span> <span class="nv">f</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="hy.gensym">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.</span></code><code class="sig-name descname"><span class="pre">gensym</span></code>  <em><span class="pre">[</span><span class="n"><span class="pre">g</span></span><span class="o"> </span><span class="default_value"><span class="pre">G</span></span><span class="pre">]</span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.gensym" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a unique symbol for use in macros without accidental name clashes.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.9.12.</span></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Section <a class="reference internal" href="language/internals.html#using-gensym"><span class="std std-ref">Using gensym for Safer Macros</span></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span>=&gt; (hy.gensym)
&#39;_G￿1
</pre></div>
</div>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span>=&gt; (hy.gensym &quot;x&quot;)
&#39;_x￿2
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="hy.as-model">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.</span></code><code class="sig-name descname"><span class="pre">as-model</span></code>  <em><span class="n"><span class="pre">x</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.as-model" title="Permalink to this definition">¶</a></dt>
<dd><p>Recurisvely promote an object <code class="docutils literal notranslate"><span class="pre">x</span></code> into its canonical model form.</p>
<p>When creating macros its possible to return non-Hy model objects or
even create an expression with non-Hy model elements:</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="kd">defmacro </span><span class="nv">hello</span> <span class="p">[]</span>
<span class="nv">...</span>  <span class="s">&quot;world!&quot;</span><span class="p">)</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="kd">defmacro </span><span class="nv">print-inc</span> <span class="p">[</span><span class="nv">a</span><span class="p">]</span>
<span class="nv">...</span>  <span class="o">`</span><span class="p">(</span><span class="nb">print </span><span class="o">~</span><span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="mi">1</span><span class="p">)))</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">print-inc</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">2</span>  <span class="c1">; in this case the unquote form (+ 1 1) would splice the literal</span>
   <span class="c1">; integer ``2`` into the print statement, *not* the model representation</span>
   <span class="c1">; ``(hy.model.Integer 2)``</span>
</pre></div>
</div>
<p>This is perfectly fine, because Hy autoboxes these literal values into their
respective model forms at compilation time.</p>
<p>The one case where this distinction between the spliced composit form and
the canonical model tree representation matters, is when comparing some
spliced model tree with another known tree:</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">= </span><span class="o">`</span><span class="p">(</span><span class="nb">print </span><span class="o">~</span><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">print </span><span class="mi">2</span><span class="p">))</span>
<span class="nv">False</span>  <span class="c1">; False because the literal int ``2`` in the spliced form is not</span>
       <span class="c1">; equal to the ``(hy.model.Integer 2)`` value in the known form.</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">= </span><span class="p">(</span><span class="nf">hy.as-model</span> <span class="o">`</span><span class="p">(</span><span class="nb">print </span><span class="o">~</span><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">print </span><span class="mi">2</span><span class="p">)))</span>
<span class="nv">True</span>  <span class="c1">; True because ``as-model`` has walked the expression and promoted</span>
      <span class="c1">; the literal int ``2`` to its model for ``(hy.model.Integer 2)``</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-hy.pyops">
<span id="python-operators"></span><h2>Python Operators<a class="headerlink" href="#module-hy.pyops" title="Permalink to this headline">¶</a></h2>
<p>Python provides various <a class="reference external" href="https://docs.python.org/3/reference/expressions.html#expressions" title="(in Python v3.9)"><span class="xref std std-ref">binary and unary operators</span></a>. These are usually invoked in Hy using core macros of
the same name: for example, <code class="docutils literal notranslate"><span class="pre">(+</span> <span class="pre">1</span> <span class="pre">2)</span></code> calls the core macro named
<code class="docutils literal notranslate"><span class="pre">+</span></code>, which uses Python’s addition operator. An exception to the names
being the same is that Python’s <code class="docutils literal notranslate"><span class="pre">==</span></code> is called <code class="docutils literal notranslate"><span class="pre">=</span></code> in Hy.</p>
<p>By importing from the module <code class="docutils literal notranslate"><span class="pre">hy.pyops</span></code> (typically with a star import,
as in <code class="docutils literal notranslate"><span class="pre">(import</span> <span class="pre">hy.pyops</span> <span class="pre">*)</span></code>), you can also use these operators as
functions. Functions are first-class objects, so you can say things like
<code class="docutils literal notranslate"><span class="pre">(map</span> <span class="pre">-</span> <span class="pre">xs)</span></code> to negate all the numbers in the list <code class="docutils literal notranslate"><span class="pre">xs</span></code>. Since
macros shadow functions, forms like <code class="docutils literal notranslate"><span class="pre">(-</span> <span class="pre">1</span> <span class="pre">2)</span></code> will still call the
macro instead of the function.</p>
<p>The functions in <code class="docutils literal notranslate"><span class="pre">hy.pyops</span></code> have the same semantics as their macro
equivalents, with one exception: functions can’t short-circuit, so the
functions for the logical operators, such as <code class="docutils literal notranslate"><span class="pre">and</span></code>, unconditionally
evaluate all arguments.</p>
<dl class="hy function">
<dt id="hy.pyops.!=">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.pyops.</span></code><code class="sig-name descname"><span class="pre">!=</span></code>  <em><span class="n"><span class="pre">a1</span></span></em> <em><span class="n"><span class="pre">a2</span></span></em> <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">a-rest</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.pyops.!=" title="Permalink to this definition">¶</a></dt>
<dd><p>Shadowed <cite>!=</cite> operator perform neq comparison on <cite>a1</cite> by <cite>a2</cite>, …, <cite>a-rest</cite>.</p>
</dd></dl>

<dl class="hy function">
<dt id="hy.pyops.%">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.pyops.</span></code><code class="sig-name descname"><span class="pre">%</span></code>  <em><span class="n"><span class="pre">x</span></span></em> <em><span class="n"><span class="pre">y</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.pyops.%" title="Permalink to this definition">¶</a></dt>
<dd><p>Shadowed <cite>%</cite> operator takes <cite>x</cite> modulo <cite>y</cite>.</p>
</dd></dl>

<dl class="hy function">
<dt id="hy.pyops.&amp;">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.pyops.</span></code><code class="sig-name descname"><span class="pre">&amp;</span></code>  <em><span class="n"><span class="pre">a1</span></span></em> <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">a-rest</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.pyops.&" title="Permalink to this definition">¶</a></dt>
<dd><p>Shadowed <cite>&amp;</cite> operator performs bitwise-and on <cite>a1</cite> by each <cite>a-rest</cite>.</p>
</dd></dl>

<dl class="hy function">
<dt id="hy.pyops.*">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.pyops.</span></code><code class="sig-name descname"><span class="pre">*</span></code>  <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">args</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.pyops.*" title="Permalink to this definition">¶</a></dt>
<dd><p>Shadowed <cite>*</cite> operator multiplies <cite>args</cite>.</p>
</dd></dl>

<dl class="hy function">
<dt id="hy.pyops.**">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.pyops.</span></code><code class="sig-name descname"><span class="pre">**</span></code>  <em><span class="n"><span class="pre">a1</span></span></em> <em><span class="n"><span class="pre">a2</span></span></em> <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">a-rest</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.pyops.**" title="Permalink to this definition">¶</a></dt>
<dd><p>Shadowed <cite>**</cite> operator takes <cite>a1</cite> to the power of <cite>a2</cite>, …, <cite>a-rest</cite>.</p>
</dd></dl>

<dl class="hy function">
<dt id="hy.pyops.+">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.pyops.</span></code><code class="sig-name descname"><span class="pre">+</span></code>  <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">args</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.pyops.+" title="Permalink to this definition">¶</a></dt>
<dd><p>Shadowed <cite>+</cite> operator adds <cite>args</cite>.</p>
</dd></dl>

<dl class="hy function">
<dt id="hy.pyops.-">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.pyops.</span></code><code class="sig-name descname"><span class="pre">-</span></code>  <em><span class="n"><span class="pre">a1</span></span></em> <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">a-rest</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.pyops.-" title="Permalink to this definition">¶</a></dt>
<dd><p>Shadowed <cite>-</cite> operator subtracts each <cite>a-rest</cite> from <cite>a1</cite>.</p>
</dd></dl>

<dl class="hy function">
<dt id="hy.pyops./">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.pyops.</span></code><code class="sig-name descname"><span class="pre">/</span></code>  <em><span class="n"><span class="pre">a1</span></span></em> <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">a-rest</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.pyops./" title="Permalink to this definition">¶</a></dt>
<dd><p>Shadowed <cite>/</cite> operator divides <cite>a1</cite> by each <cite>a-rest</cite>.</p>
</dd></dl>

<dl class="hy function">
<dt id="hy.pyops.//">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.pyops.</span></code><code class="sig-name descname"><span class="pre">//</span></code>  <em><span class="n"><span class="pre">a1</span></span></em> <em><span class="n"><span class="pre">a2</span></span></em> <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">a-rest</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.pyops.//" title="Permalink to this definition">¶</a></dt>
<dd><p>Shadowed <cite>//</cite> operator floor divides <cite>a1</cite> by <cite>a2</cite>, …, <cite>a-rest</cite>.</p>
</dd></dl>

<dl class="hy function">
<dt id="hy.pyops.&lt;">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.pyops.</span></code><code class="sig-name descname"><span class="pre">&lt;</span></code>  <em><span class="n"><span class="pre">a1</span></span></em> <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">a-rest</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.pyops.<" title="Permalink to this definition">¶</a></dt>
<dd><p>Shadowed <cite>&lt;</cite> operator perform lt comparison on <cite>a1</cite> by each <cite>a-rest</cite>.</p>
</dd></dl>

<dl class="hy function">
<dt id="hy.pyops.&lt;&lt;">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.pyops.</span></code><code class="sig-name descname"><span class="pre">&lt;&lt;</span></code>  <em><span class="n"><span class="pre">a1</span></span></em> <em><span class="n"><span class="pre">a2</span></span></em> <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">a-rest</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.pyops.<<" title="Permalink to this definition">¶</a></dt>
<dd><p>Shadowed <cite>&lt;&lt;</cite> operator performs left-shift on <cite>a1</cite> by <cite>a2</cite>, …, <cite>a-rest</cite>.</p>
</dd></dl>

<dl class="hy function">
<dt id="hy.pyops.&lt;=">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.pyops.</span></code><code class="sig-name descname"><span class="pre">&lt;=</span></code>  <em><span class="n"><span class="pre">a1</span></span></em> <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">a-rest</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.pyops.<=" title="Permalink to this definition">¶</a></dt>
<dd><p>Shadowed <cite>&lt;=</cite> operator perform le comparison on <cite>a1</cite> by each <cite>a-rest</cite>.</p>
</dd></dl>

<dl class="hy function">
<dt id="hy.pyops.=">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.pyops.</span></code><code class="sig-name descname"><span class="pre">=</span></code>  <em><span class="n"><span class="pre">a1</span></span></em> <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">a-rest</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.pyops.=" title="Permalink to this definition">¶</a></dt>
<dd><p>Shadowed <cite>=</cite> operator perform eq comparison on <cite>a1</cite> by each <cite>a-rest</cite>.</p>
</dd></dl>

<dl class="hy function">
<dt id="hy.pyops.&gt;">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.pyops.</span></code><code class="sig-name descname"><span class="pre">&gt;</span></code>  <em><span class="n"><span class="pre">a1</span></span></em> <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">a-rest</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.pyops.>" title="Permalink to this definition">¶</a></dt>
<dd><p>Shadowed <cite>&gt;</cite> operator perform gt comparison on <cite>a1</cite> by each <cite>a-rest</cite>.</p>
</dd></dl>

<dl class="hy function">
<dt id="hy.pyops.&gt;=">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.pyops.</span></code><code class="sig-name descname"><span class="pre">&gt;=</span></code>  <em><span class="n"><span class="pre">a1</span></span></em> <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">a-rest</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.pyops.>=" title="Permalink to this definition">¶</a></dt>
<dd><p>Shadowed <cite>&gt;=</cite> operator perform ge comparison on <cite>a1</cite> by each <cite>a-rest</cite>.</p>
</dd></dl>

<dl class="hy function">
<dt id="hy.pyops.&gt;&gt;">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.pyops.</span></code><code class="sig-name descname"><span class="pre">&gt;&gt;</span></code>  <em><span class="n"><span class="pre">a1</span></span></em> <em><span class="n"><span class="pre">a2</span></span></em> <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">a-rest</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.pyops.>>" title="Permalink to this definition">¶</a></dt>
<dd><p>Shadowed <cite>&gt;&gt;</cite> operator performs right-shift on <cite>a1</cite> by <cite>a2</cite>, …, <cite>a-rest</cite>.</p>
</dd></dl>

<dl class="hy function">
<dt id="hy.pyops.&#64;">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.pyops.</span></code><code class="sig-name descname"><span class="pre">&#64;</span></code>  <em><span class="n"><span class="pre">a1</span></span></em> <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">a-rest</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.pyops.@" title="Permalink to this definition">¶</a></dt>
<dd><p>Shadowed <cite>&#64;</cite> operator matrix multiples <cite>a1</cite> by each <cite>a-rest</cite>.</p>
</dd></dl>

<dl class="hy function">
<dt id="hy.pyops.[x y]">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.pyops.</span></code><code class="sig-name descname"><span class="pre">[x</span> <span class="pre">y]</span></code><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.pyops.[x y]" title="Permalink to this definition">¶</a></dt>
<dd><p>Shadowed <cite>^</cite> operator performs bitwise-xor on <cite>x</cite> and <cite>y</cite>.</p>
</dd></dl>

<dl class="hy function">
<dt id="hy.pyops.and">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.pyops.</span></code><code class="sig-name descname"><span class="pre">and</span></code>  <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">args</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.pyops.and" title="Permalink to this definition">¶</a></dt>
<dd><p>Shadowed <cite>and</cite> keyword perform and on <cite>args</cite>.</p>
<p><code class="docutils literal notranslate"><span class="pre">and</span></code> is used in logical expressions. It takes at least two parameters.
If all parameters evaluate to <code class="docutils literal notranslate"><span class="pre">True</span></code>, the last parameter is returned.
In any other case, the first false value will be returned.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">and</span></code> short-circuits and stops evaluating parameters as soon as the first
false is encountered.</p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">and </span><span class="nv">True</span> <span class="nv">False</span><span class="p">)</span>
<span class="nv">False</span>
</pre></div>
</div>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">and </span><span class="nv">False</span> <span class="p">(</span><span class="nb">print </span><span class="s">&quot;hello&quot;</span><span class="p">))</span>
<span class="nv">False</span>
</pre></div>
</div>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">and </span><span class="nv">True</span> <span class="nv">True</span><span class="p">)</span>
<span class="nv">True</span>
</pre></div>
</div>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">and </span><span class="nv">True</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">1</span>
</pre></div>
</div>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">and </span><span class="nv">True</span> <span class="p">[]</span> <span class="nv">False</span> <span class="nv">True</span><span class="p">)</span>
<span class="p">[]</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="hy.pyops.get">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.pyops.</span></code><code class="sig-name descname"><span class="pre">get</span></code>  <em><span class="n"><span class="pre">coll</span></span></em> <em><span class="n"><span class="pre">key1</span></span></em> <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">keys</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.pyops.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Access item in <cite>coll</cite> indexed by <cite>key1</cite>, with optional <cite>keys</cite> nested-access.</p>
<p><code class="docutils literal notranslate"><span class="pre">get</span></code> is used to access single elements in collections. <code class="docutils literal notranslate"><span class="pre">get</span></code> takes at
least two parameters: the <em>data structure</em> and the <em>index</em> or <em>key</em> of the
item. It will then return the corresponding value from the collection. If
multiple <em>index</em> or <em>key</em> values are provided, they are used to access
successive elements in a nested structure.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">get</span></code> raises a KeyError if a dictionary is queried for a
non-existing key.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">get</span></code> raises an IndexError if a list or a tuple is queried for an
index that is out of bounds.</p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">do</span>
<span class="nv">...</span>   <span class="p">(</span><span class="nf">setv</span> <span class="nv">animals</span> <span class="p">{</span><span class="s">&quot;dog&quot;</span> <span class="s">&quot;bark&quot;</span> <span class="s">&quot;cat&quot;</span> <span class="s">&quot;meow&quot;</span><span class="p">}</span>
<span class="nv">...</span>         <span class="nv">numbers</span> <span class="p">(</span>, <span class="s">&quot;zero&quot;</span> <span class="s">&quot;one&quot;</span> <span class="s">&quot;two&quot;</span> <span class="s">&quot;three&quot;</span><span class="p">)</span>
<span class="nv">...</span>         <span class="nv">nested</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="p">[</span><span class="s">&quot;a&quot;</span> <span class="s">&quot;b&quot;</span> <span class="s">&quot;c&quot;</span><span class="p">]</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">])</span>
<span class="nv">...</span>   <span class="p">(</span><span class="nb">print </span><span class="p">(</span><span class="nb">get </span><span class="nv">animals</span> <span class="s">&quot;dog&quot;</span><span class="p">))</span>
<span class="nv">...</span>   <span class="p">(</span><span class="nb">print </span><span class="p">(</span><span class="nb">get </span><span class="nv">numbers</span> <span class="mi">2</span><span class="p">))</span>
<span class="nv">...</span>   <span class="p">(</span><span class="nb">print </span><span class="p">(</span><span class="nb">get </span><span class="nv">nested</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">))</span>
<span class="nv">bark</span>
<span class="nv">two</span>
<span class="nv">b</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="hy.pyops.in">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.pyops.</span></code><code class="sig-name descname"><span class="pre">in</span></code>  <em><span class="n"><span class="pre">a1</span></span></em> <em><span class="n"><span class="pre">a2</span></span></em> <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">a-rest</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.pyops.in" title="Permalink to this definition">¶</a></dt>
<dd><p>Shadowed <cite>in</cite> keyword perform <cite>a1</cite> in <cite>a2</cite> in ….</p>
</dd></dl>

<dl class="hy function">
<dt id="hy.pyops.is">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.pyops.</span></code><code class="sig-name descname"><span class="pre">is</span></code>  <em><span class="n"><span class="pre">a1</span></span></em> <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">a-rest</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.pyops.is" title="Permalink to this definition">¶</a></dt>
<dd><p>Shadowed <cite>is</cite> keyword perform is on <cite>a1</cite> by each <cite>a-rest</cite>.</p>
</dd></dl>

<dl class="hy function">
<dt id="hy.pyops.not">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.pyops.</span></code><code class="sig-name descname"><span class="pre">not</span></code>  <em><span class="n"><span class="pre">x</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.pyops.not" title="Permalink to this definition">¶</a></dt>
<dd><p>Shadowed <cite>not</cite> keyword perform not on <cite>x</cite>.</p>
<p><code class="docutils literal notranslate"><span class="pre">not</span></code> is used in logical expressions. It takes a single parameter and
returns a reversed truth value. If <code class="docutils literal notranslate"><span class="pre">True</span></code> is given as a parameter, <code class="docutils literal notranslate"><span class="pre">False</span></code>
will be returned, and vice-versa.</p>
<p class="rubric">Examples</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">not </span><span class="nv">True</span><span class="p">)</span>
<span class="nv">False</span>
</pre></div>
</div>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">not </span><span class="nv">False</span><span class="p">)</span>
<span class="nv">True</span>
</pre></div>
</div>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">not </span><span class="nv">None</span><span class="p">)</span>
<span class="nv">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="hy.pyops.not-in">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.pyops.</span></code><code class="sig-name descname"><span class="pre">not-in</span></code>  <em><span class="n"><span class="pre">a1</span></span></em> <em><span class="n"><span class="pre">a2</span></span></em> <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">a-rest</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.pyops.not-in" title="Permalink to this definition">¶</a></dt>
<dd><p>Shadowed <cite>not in</cite> keyword perform <cite>a1</cite> not in <cite>a2</cite> not in….</p>
</dd></dl>

<dl class="hy function">
<dt id="hy.pyops.not?">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.pyops.</span></code><code class="sig-name descname"><span class="pre">not?</span></code>  <em><span class="n"><span class="pre">a1</span></span></em> <em><span class="n"><span class="pre">a2</span></span></em> <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">a-rest</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.pyops.not?" title="Permalink to this definition">¶</a></dt>
<dd><p>Shadowed <cite>is-not</cite> keyword perform is-not on <cite>a1</cite> by <cite>a2</cite>, …, <cite>a-rest</cite>.</p>
</dd></dl>

<dl class="hy function">
<dt id="hy.pyops.or">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.pyops.</span></code><code class="sig-name descname"><span class="pre">or</span></code>  <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">args</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.pyops.or" title="Permalink to this definition">¶</a></dt>
<dd><p>Shadowed <cite>or</cite> keyword perform or on <cite>args</cite>.</p>
<p><code class="docutils literal notranslate"><span class="pre">or</span></code> is used in logical expressions. It takes at least two parameters. It
will return the first non-false parameter. If no such value exists, the last
parameter will be returned.</p>
<p class="rubric">Examples</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">or </span><span class="nv">True</span> <span class="nv">False</span><span class="p">)</span>
<span class="nv">True</span>
</pre></div>
</div>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">or </span><span class="nv">False</span> <span class="nv">False</span><span class="p">)</span>
<span class="nv">False</span>
</pre></div>
</div>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">or </span><span class="nv">False</span> <span class="mi">1</span> <span class="nv">True</span> <span class="nv">False</span><span class="p">)</span>
<span class="mi">1</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">or</span></code> short-circuits and stops evaluating parameters as soon as the
first true value is encountered.</p>
</div>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">or </span><span class="nv">True</span> <span class="p">(</span><span class="nb">print </span><span class="s">&quot;hello&quot;</span><span class="p">))</span>
<span class="nv">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="hy function">
<dt id="hy.pyops.|">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.pyops.</span></code><code class="sig-name descname"><span class="pre">|</span></code>  <em><span class="o"><span class="pre">#*</span></span> <span class="n"><span class="pre">args</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.pyops.|" title="Permalink to this definition">¶</a></dt>
<dd><p>Shadowed <cite>|</cite> operator performs bitwise-or on <cite>a1</cite> by each <cite>a-rest</cite>.</p>
</dd></dl>

<dl class="hy function">
<dt id="hy.pyops.~">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.pyops.</span></code><code class="sig-name descname"><span class="pre">~</span></code>  <em><span class="n"><span class="pre">x</span></span></em><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.pyops.~" title="Permalink to this definition">¶</a></dt>
<dd><p>Shadowed <cite>~</cite> operator performs bitwise-negation on <cite>x</cite>.</p>
</dd></dl>

</div>
<div class="section" id="module-hy.reserved">
<span id="reserved"></span><h2>Reserved<a class="headerlink" href="#module-hy.reserved" title="Permalink to this headline">¶</a></h2>
<dl class="hy function">
<dt id="hy.reserved.macros">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.reserved.</span></code><code class="sig-name descname"><span class="pre">macros</span></code><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.reserved.macros" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a frozenset of Hy’s core macro names.</p>
</dd></dl>

<dl class="hy function">
<dt id="hy.reserved.names">
<code class="sig-prename descclassname"><span class="pre">(</span></code><code class="sig-prename descclassname"><span class="pre">hy.reserved.</span></code><code class="sig-name descname"><span class="pre">names</span></code><code class="sig-prename descclassname"><span class="pre">)</span></code><a class="headerlink" href="#hy.reserved.names" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a frozenset of reserved symbol names.</p>
<p>The result of the first call is cached.</p>
<p>The output includes all of Hy’s core functions and macros, plus all
Python reserved words. All names are in unmangled form (e.g.,
<code class="docutils literal notranslate"><span class="pre">not-in</span></code> rather than <code class="docutils literal notranslate"><span class="pre">not_in</span></code>).</p>
<p class="rubric">Examples</p>
<div class="highlight-clojure notranslate"><div class="highlight"><pre><span></span><span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">import </span><span class="nv">hy.extra.reserved</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">in</span> <span class="s">&quot;defclass&quot;</span> <span class="p">(</span><span class="nf">hy.extra.reserved.names</span><span class="p">))</span>
<span class="nv">True</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="hacking.html" class="btn btn-neutral float-right" title="Hacking on Hy" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="cheatsheet.html" class="btn btn-neutral float-left" title="Cheatsheet" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021 the authors.

    </p>
  </div> 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>